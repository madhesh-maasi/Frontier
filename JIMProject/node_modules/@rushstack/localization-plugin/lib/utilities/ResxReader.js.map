{"version":3,"file":"ResxReader.js","sourceRoot":"","sources":["../../src/utilities/ResxReader.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { FileSystem, ITerminal, Text, NewlineKind } from '@rushstack/node-core-library';\nimport { XmlDocument, XmlElement } from 'xmldoc';\n\nimport { ILocalizedString, ILocalizationFile } from '../interfaces';\n\nconst STRING_NAME_RESX: RegExp = /^[A-z_$][A-z0-9_$]*$/;\n\nexport interface IResxReaderOptions {\n  resxFilePath: string;\n  terminal: ITerminal;\n  newlineNormalization: NewlineKind | undefined;\n}\n\ninterface ILoggingFunctions {\n  logError: (message: string) => void;\n  logWarning: (message: string) => void;\n  logFileError: (message: string, filePath: string, line?: number, position?: number) => void;\n  logFileWarning: (message: string, filePath: string, line?: number, position?: number) => void;\n}\n\ninterface IResxReaderOptionsInternal {\n  resxFilePath: string;\n  resxContents: string;\n  loggingFunctions: ILoggingFunctions;\n  newlineNormalization: NewlineKind | undefined;\n}\n\nexport class ResxReader {\n  public static readResxFileAsLocFile(options: IResxReaderOptions): ILocalizationFile {\n    const resxContents: string = FileSystem.readFile(options.resxFilePath);\n    return ResxReader.readResxAsLocFile(resxContents, options);\n  }\n\n  public static readResxAsLocFile(resxContents: string, options: IResxReaderOptions): ILocalizationFile {\n    const writeError: (message: string) => void = options.terminal.writeErrorLine.bind(options.terminal);\n    const writeWarning: (message: string) => void = options.terminal.writeWarningLine.bind(options.terminal);\n    const loggingFunctions: ILoggingFunctions = {\n      logError: (message: string) => writeError(message),\n      logWarning: (message: string) => writeWarning(message),\n      logFileError: (message: string, filePath: string, line?: number, position?: number) => {\n        ResxReader._logWithLocation(writeError, message, filePath, line, position);\n      },\n      logFileWarning: (message: string, filePath: string, line?: number, position?: number) => {\n        ResxReader._logWithLocation(writeWarning, message, filePath, line, position);\n      }\n    };\n\n    return this._readResxAsLocFileInternal({\n      resxFilePath: options.resxFilePath,\n      resxContents,\n      loggingFunctions,\n      newlineNormalization: options.newlineNormalization\n    });\n  }\n\n  private static _readResxAsLocFileInternal(options: IResxReaderOptionsInternal): ILocalizationFile {\n    const xmlDocument: XmlDocument = new XmlDocument(options.resxContents);\n\n    if (xmlDocument.name !== 'root') {\n      ResxReader._logErrorWithLocation(\n        options,\n        `Expected RESX to have a \"root\" element, found \"${xmlDocument.name}\"`,\n        xmlDocument\n      );\n    }\n\n    const locFile: ILocalizationFile = {};\n\n    for (const childNode of xmlDocument.children) {\n      switch (childNode.type) {\n        case 'element': {\n          switch (childNode.name) {\n            case 'data': {\n              const stringName: string = childNode.attr.name;\n              if (!stringName) {\n                ResxReader._logErrorWithLocation(\n                  options,\n                  'Unexpected missing or empty string name',\n                  childNode\n                );\n              } else if (!STRING_NAME_RESX.test(stringName)) {\n                ResxReader._logErrorWithLocation(options, `Invalid string name \"${stringName}\"`, childNode);\n              } else {\n                if (locFile.hasOwnProperty(stringName)) {\n                  ResxReader._logErrorWithLocation(\n                    options,\n                    `Duplicate string value \"${stringName}\"`,\n                    childNode\n                  );\n                }\n\n                const locString: ILocalizedString | undefined = ResxReader._readDataElement(\n                  options,\n                  childNode\n                );\n\n                if (locString) {\n                  locFile[stringName] = locString;\n                }\n              }\n\n              break;\n            }\n\n            // Other allowed elements\n            case 'xsd:schema':\n            case 'resheader':\n              break;\n\n            default:\n              ResxReader._logErrorWithLocation(\n                options,\n                `Unexpected RESX element ${childNode.name}`,\n                childNode\n              );\n          }\n\n          break;\n        }\n\n        case 'text': {\n          if (childNode.text.trim() !== '') {\n            ResxReader._logErrorWithLocation(options, 'Found unexpected non-empty text node in RESX');\n          }\n\n          break;\n        }\n\n        case 'comment':\n          break;\n\n        default:\n          ResxReader._logErrorWithLocation(options, `Unexpected ${childNode.type} child in RESX`);\n          break;\n      }\n    }\n\n    return locFile;\n  }\n\n  private static _readDataElement(\n    options: IResxReaderOptionsInternal,\n    dataElement: XmlElement\n  ): ILocalizedString | undefined {\n    let foundCommentElement: boolean = false;\n    let foundValueElement: boolean = false;\n    let comment: string | undefined = undefined;\n    let value: string | undefined = undefined;\n\n    for (const childNode of dataElement.children) {\n      switch (childNode.type) {\n        case 'element': {\n          switch (childNode.name) {\n            case 'value': {\n              if (foundValueElement) {\n                ResxReader._logErrorWithLocation(options, 'Duplicate <value> element found', childNode);\n              } else {\n                foundValueElement = true;\n                value = ResxReader._readTextElement(options, childNode);\n                if (value && options.newlineNormalization) {\n                  value = Text.convertTo(value, options.newlineNormalization);\n                }\n              }\n\n              break;\n            }\n\n            case 'comment': {\n              if (foundCommentElement) {\n                ResxReader._logErrorWithLocation(options, 'Duplicate <comment> element found', childNode);\n              } else {\n                foundCommentElement = true;\n                comment = ResxReader._readTextElement(options, childNode);\n              }\n\n              break;\n            }\n\n            default:\n              ResxReader._logErrorWithLocation(\n                options,\n                `Unexpected RESX element ${childNode.name}`,\n                childNode\n              );\n              break;\n          }\n\n          break;\n        }\n\n        case 'text': {\n          if (childNode.text.trim() !== '') {\n            ResxReader._logErrorWithLocation(\n              options,\n              'Found unexpected non-empty text node in RESX <data> element',\n              dataElement\n            );\n          }\n\n          break;\n        }\n\n        case 'comment':\n          break;\n\n        default:\n          ResxReader._logErrorWithLocation(\n            options,\n            `Unexpected ${childNode.type} child in RESX <data> element`,\n            dataElement\n          );\n      }\n    }\n\n    if (!foundValueElement) {\n      ResxReader._logErrorWithLocation(options, 'Missing string value in <data> element', dataElement);\n    } else {\n      if (comment === undefined) {\n        ResxReader._logWarningWithLocation(options, 'Missing string comment in <data> element', dataElement);\n      }\n\n      return {\n        value: value || '',\n        comment\n      };\n    }\n  }\n\n  private static _readTextElement(\n    options: IResxReaderOptionsInternal,\n    element: XmlElement\n  ): string | undefined {\n    let foundText: string | undefined = undefined;\n\n    for (const childNode of element.children) {\n      switch (childNode.type) {\n        case 'cdata':\n        case 'text': {\n          if (foundText !== undefined) {\n            ResxReader._logErrorWithLocation(\n              options,\n              'More than one child node found containing text content',\n              element\n            );\n            break;\n          }\n\n          foundText = childNode.type === 'text' ? childNode.text : childNode.cdata;\n          break;\n        }\n\n        case 'comment':\n          break;\n\n        case 'element':\n          ResxReader._logErrorWithLocation(options, `Unexpected element`, childNode);\n          break;\n\n        default:\n          ResxReader._logErrorWithLocation(options, `Unexpected ${element.type} child`, element);\n          break;\n      }\n    }\n\n    return foundText;\n  }\n\n  private static _logErrorWithLocation(\n    options: IResxReaderOptionsInternal,\n    message: string,\n    element?: XmlElement | XmlDocument\n  ): void {\n    if (element) {\n      options.loggingFunctions.logFileError(\n        message,\n        options.resxFilePath,\n        element.line + 1,\n        element.column + 1\n      );\n    } else {\n      options.loggingFunctions.logFileError(message, options.resxFilePath);\n    }\n  }\n\n  private static _logWarningWithLocation(\n    options: IResxReaderOptionsInternal,\n    message: string,\n    element?: XmlElement | XmlDocument\n  ): void {\n    if (element) {\n      options.loggingFunctions.logFileWarning(\n        message,\n        options.resxFilePath,\n        element.line + 1,\n        element.column + 1\n      );\n    } else {\n      options.loggingFunctions.logFileWarning(message, options.resxFilePath);\n    }\n  }\n\n  private static _logWithLocation(\n    loggingFn: (message: string) => void,\n    message: string,\n    filePath: string,\n    line?: number,\n    position?: number\n  ): void {\n    let location: string;\n    if (position !== undefined) {\n      location = `${filePath}(${line},${position})`;\n    } else if (line !== undefined) {\n      location = `${filePath}(${line})`;\n    } else {\n      location = filePath;\n    }\n\n    loggingFn(`${location}: ${message}`);\n  }\n}\n"]}