{"version":3,"file":"LocFileParser.js","sourceRoot":"","sources":["../../src/utilities/LocFileParser.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAE3D,oEAAgF;AAGhF,6CAA0C;AAC1C,2CAAwC;AAiBxC,MAAM,UAAU,GAAkC,IAAI,GAAG,EAA4B,CAAC;AAEtF;;GAEG;AACH,MAAa,aAAa;IACjB,MAAM,CAAC,YAAY,CAAC,OAA6B;QACtD,MAAM,YAAY,GAAW,GAAG,OAAO,CAAC,QAAQ,IAAI,OAAO,CAAC,wBAAwB,IAAI,MAAM,EAAE,CAAC;QACjG,IAAI,UAAU,CAAC,GAAG,CAAC,YAAY,CAAC,EAAE;YAChC,MAAM,KAAK,GAAqB,UAAU,CAAC,GAAG,CAAC,YAAY,CAAE,CAAC;YAC9D,IAAI,KAAK,CAAC,OAAO,KAAK,OAAO,CAAC,OAAO,EAAE;gBACrC,OAAO,KAAK,CAAC,UAAU,CAAC;aACzB;SACF;QAED,IAAI,UAA6B,CAAC;QAClC,IAAI,UAAU,CAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,EAAE;YACrC,UAAU,GAAG,uBAAU,CAAC,iBAAiB,CAAC,OAAO,CAAC,OAAO,EAAE;gBACzD,QAAQ,EAAE,OAAO,CAAC,QAAQ;gBAC1B,YAAY,EAAE,OAAO,CAAC,QAAQ;gBAC9B,oBAAoB,EAAE,OAAO,CAAC,wBAAwB;aACvD,CAAC,CAAC;SACJ;aAAM;YACL,UAAU,GAAG,4BAAQ,CAAC,WAAW,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;YACnD,IAAI;gBACF,qBAAS,CAAC,eAAe,CAAC,cAAc,CAAC,UAAU,EAAE,OAAO,CAAC,QAAQ,CAAC,CAAC;aACxE;YAAC,OAAO,CAAC,EAAE;gBACV,OAAO,CAAC,QAAQ,CAAC,UAAU,CAAC,mCAAmC,CAAC,EAAE,CAAC,CAAC;aACrE;SACF;QAED,UAAU,CAAC,GAAG,CAAC,YAAY,EAAE,EAAE,OAAO,EAAE,OAAO,CAAC,OAAO,EAAE,UAAU,EAAE,CAAC,CAAC;QACvE,OAAO,UAAU,CAAC;IACpB,CAAC;CACF;AA7BD,sCA6BC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { ITerminal, NewlineKind, JsonFile } from '@rushstack/node-core-library';\n\nimport { ILocalizationFile } from '../interfaces';\nimport { ResxReader } from './ResxReader';\nimport { Constants } from './Constants';\n\n/**\n * @internal\n */\nexport interface IParseLocFileOptions {\n  terminal: ITerminal;\n  filePath: string;\n  content: string;\n  resxNewlineNormalization: NewlineKind | undefined;\n}\n\ninterface IParseCacheEntry {\n  content: string;\n  parsedFile: ILocalizationFile;\n}\n\nconst parseCache: Map<string, IParseCacheEntry> = new Map<string, IParseCacheEntry>();\n\n/**\n * @internal\n */\nexport class LocFileParser {\n  public static parseLocFile(options: IParseLocFileOptions): ILocalizationFile {\n    const fileCacheKey: string = `${options.filePath}?${options.resxNewlineNormalization || 'none'}`;\n    if (parseCache.has(fileCacheKey)) {\n      const entry: IParseCacheEntry = parseCache.get(fileCacheKey)!;\n      if (entry.content === options.content) {\n        return entry.parsedFile;\n      }\n    }\n\n    let parsedFile: ILocalizationFile;\n    if (/\\.resx$/i.test(options.filePath)) {\n      parsedFile = ResxReader.readResxAsLocFile(options.content, {\n        terminal: options.terminal,\n        resxFilePath: options.filePath,\n        newlineNormalization: options.resxNewlineNormalization\n      });\n    } else {\n      parsedFile = JsonFile.parseString(options.content);\n      try {\n        Constants.LOC_JSON_SCHEMA.validateObject(parsedFile, options.filePath);\n      } catch (e) {\n        options.terminal.writeError(`The loc file is invalid. Error: ${e}`);\n      }\n    }\n\n    parseCache.set(fileCacheKey, { content: options.content, parsedFile });\n    return parsedFile;\n  }\n}\n"]}