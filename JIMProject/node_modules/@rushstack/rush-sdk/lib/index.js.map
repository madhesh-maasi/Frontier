{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;AAE3D,2CAA6B;AAC7B,oEAAuF;AAEvF,MAAM,aAAa,GAAW,qBAAqB,CAAC;AAQpD,qGAAqG;AACrG,gGAAgG;AAChG,IAAI,aAAa,GAAkC,MAAM,CAAC,uBAAuB,CAAC;AAElF,6FAA6F;AAC7F,+FAA+F;AAC/F,IAAI,aAAa,KAAK,SAAS,EAAE;IAC/B,MAAM,aAAa,GAAuB,MAAA,MAAM,aAAN,MAAM,uBAAN,MAAM,CAAE,MAAM,0CAAE,QAAQ,CAAC;IACnE,IAAI,aAAa,KAAK,SAAS,EAAE;QAC/B,MAAM,mBAAmB,GACvB,qCAAiB,CAAC,QAAQ,CAAC,sBAAsB,CAAC,aAAa,CAAC,CAAC;QAEnE,IAAI,mBAAmB,KAAK,SAAS,EAAE;YACrC,MAAM,iBAAiB,GAAiB,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,mBAAmB,EAAE,cAAc,CAAC,CAAC,CAAC;YAEhG,6DAA6D;YAC7D,IACE,CAAC,iBAAiB,CAAC,YAAY,IAAI,iBAAiB,CAAC,YAAY,CAAC,aAAa,CAAC,KAAK,SAAS,CAAC;gBAC/F,CAAC,iBAAiB,CAAC,eAAe;oBAChC,iBAAiB,CAAC,eAAe,CAAC,aAAa,CAAC,KAAK,SAAS,CAAC;gBACjE,CAAC,iBAAiB,CAAC,gBAAgB;oBACjC,iBAAiB,CAAC,gBAAgB,CAAC,aAAa,CAAC,KAAK,SAAS,CAAC,EAClE;gBACA,mDAAmD;gBACnD,IAAI;oBACF,MAAM,iBAAiB,GAAW,0BAAM,CAAC,aAAa,CAAC;wBACrD,UAAU,EAAE,aAAa;wBACzB,cAAc,EAAE,mBAAmB;qBACpC,CAAC,CAAC;oBAEH,aAAa,GAAG,OAAO,CAAC,iBAAiB,CAAC,CAAC;iBAC5C;gBAAC,OAAO,KAAK,EAAE;oBACd,6CAA6C;iBAC9C;gBAED,oFAAoF;gBACpF,qGAAqG;gBACrG,IAAI,aAAa,KAAK,SAAS,EAAE;oBAC/B,+EAA+E;oBAC/E,gEAAgE;oBAChE,MAAM,CAAC,uBAAuB,GAAG,aAAa,CAAC;iBAChD;aACF;SACF;KACF;CACF;AAED,yGAAyG;AACzG,4GAA4G;AAC5G,EAAE;AACF,sBAAsB;AACtB,IAAI,aAAa,KAAK,SAAS,EAAE;IAC/B,qGAAqG;IACrG,wGAAwG;IACxG,2CAA2C;IAC3C,MAAM,IAAI,KAAK,CAAC,qEAAqE,CAAC,CAAC;CACxF;AAED,uCAAuC;AACvC,KAAK,MAAM,QAAQ,IAAI,aAAa,EAAE;IACpC,IAAI,QAAQ,KAAK,SAAS,IAAI,CAAC,OAAO,CAAC,cAAc,CAAC,QAAQ,CAAC,EAAE;QAC/D,MAAM,uBAAuB,GAAsB,aAAa,CAAC;QAEjE,0CAA0C;QAC1C,MAAM,CAAC,cAAc,CAAC,OAAO,EAAE,QAAQ,EAAE;YACvC,UAAU,EAAE,IAAI;YAChB,GAAG,EAAE;gBACH,OAAO,uBAAuB,CAAC,QAAQ,CAAC,CAAC;YAC3C,CAAC;SACF,CAAC,CAAC;KACJ;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport { Import, IPackageJson, PackageJsonLookup } from '@rushstack/node-core-library';\n\nconst RUSH_LIB_NAME: string = '@microsoft/rush-lib';\n\ntype RushLibModuleType = Record<string, unknown>;\ndeclare const global: NodeJS.Global &\n  typeof globalThis & {\n    ___rush___rushLibModule?: RushLibModuleType;\n  };\n\n// SCENARIO 1:  Rush's PluginManager has initialized \"rush-sdk\" with Rush's own instance of rush-lib.\n// The Rush host process will assign \"global.___rush___rushLibModule\" before loading the plugin.\nlet rushLibModule: RushLibModuleType | undefined = global.___rush___rushLibModule;\n\n// SCENARIO 2:  The project importing \"rush-sdk\" has installed its own instance of \"rush-lib\"\n// as a package.json dependency.  For example, this is used by the Jest tests for Rush plugins.\nif (rushLibModule === undefined) {\n  const importingPath: string | undefined = module?.parent?.filename;\n  if (importingPath !== undefined) {\n    const callerPackageFolder: string | undefined =\n      PackageJsonLookup.instance.tryGetPackageFolderFor(importingPath);\n\n    if (callerPackageFolder !== undefined) {\n      const callerPackageJson: IPackageJson = require(path.join(callerPackageFolder, 'package.json'));\n\n      // Does the caller properly declare a dependency on rush-lib?\n      if (\n        (callerPackageJson.dependencies && callerPackageJson.dependencies[RUSH_LIB_NAME] !== undefined) ||\n        (callerPackageJson.devDependencies &&\n          callerPackageJson.devDependencies[RUSH_LIB_NAME] !== undefined) ||\n        (callerPackageJson.peerDependencies &&\n          callerPackageJson.peerDependencies[RUSH_LIB_NAME] !== undefined)\n      ) {\n        // Try to resolve rush-lib from the caller's folder\n        try {\n          const rushLibModulePath: string = Import.resolveModule({\n            modulePath: RUSH_LIB_NAME,\n            baseFolderPath: callerPackageFolder\n          });\n\n          rushLibModule = require(rushLibModulePath);\n        } catch (error) {\n          // If we fail to resolve it, ignore the error\n        }\n\n        // If two different libraries invoke `rush-sdk`, and one of them provides \"rush-lib\"\n        // then the first version to be loaded wins.  We do not support side-by-side instances of \"rush-lib\".\n        if (rushLibModule !== undefined) {\n          // TODO: When we implement Scenario 3, we should also add some diagnostic state\n          // to track which scenario is active and how it got initialized.\n          global.___rush___rushLibModule = rushLibModule;\n        }\n      }\n    }\n  }\n}\n\n// SCENARIO 3:  A tool or script depends on \"rush-sdk\", and is meant to be used inside a monorepo folder.\n// In this case, we can use install-run-rush.js to obtain the appropriate rush-lib version for the monorepo.\n//\n// NOT IMPLEMENTED YET\nif (rushLibModule === undefined) {\n  // This error indicates that a project is trying to import \"@rushstack/rush-sdk\", but the Rush engine\n  // instance cannot be found.  If you are writing Jest tests for a Rush plugin, add \"@microsoft/rush-lib\"\n  // to the devDependencies for your project.\n  throw new Error('The \"@rushstack/rush-sdk\" package context has not been initialized.');\n}\n\n// Based on TypeScript's __exportStar()\nfor (const property in rushLibModule) {\n  if (property !== 'default' && !exports.hasOwnProperty(property)) {\n    const rushLibModuleForClosure: RushLibModuleType = rushLibModule;\n\n    // Based on TypeScript's __createBinding()\n    Object.defineProperty(exports, property, {\n      enumerable: true,\n      get: function () {\n        return rushLibModuleForClosure[property];\n      }\n    });\n  }\n}\n"]}