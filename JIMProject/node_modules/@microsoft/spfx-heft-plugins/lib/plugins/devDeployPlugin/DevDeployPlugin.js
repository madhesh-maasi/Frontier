"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DevDeployHooks = void 0;
const tapable_1 = require("tapable");
const SpDevDeploy_1 = require("./SpDevDeploy");
const node_core_library_1 = require("@rushstack/node-core-library");
const DevDeployHelper_1 = require("./DevDeployHelper");
const AzureUploader_1 = require("../../utilities/AzureUploader");
/**
 * @public
 */
class DevDeployHooks {
    constructor() {
        /**
         * Initialize
         */
        this.init = new tapable_1.AsyncParallelHook(['deployOptions']);
        /**
         * Perform any pre processing such as delete any existing deployment info json, clean up dist folder, etc.
         */
        this.preProcess = new tapable_1.SyncHook();
        /**
         * Gets the files to be deployed to the CDN
         */
        this.getFiles = new tapable_1.AsyncSeriesWaterfallHook([
            'files'
        ]);
        /**
         * Gets the name of the folder in the container into which files should be uploaded
         */
        this.getContainerFolderName = new tapable_1.SyncWaterfallHook([
            'containerFolderName'
        ]);
        /**
         * Gets the name of the Azure storage account
         */
        this.getStorageAccountName = new tapable_1.SyncWaterfallHook([
            'storageAccountName'
        ]);
        /**
         * Gets the name of the container
         */
        this.getContainerName = new tapable_1.SyncWaterfallHook(['containerName']);
        /**
         * Gets a SAS for the storage container
         */
        this.getStorageSas = new tapable_1.AsyncSeriesWaterfallHook([
            'storageSas'
        ]);
        /**
         * Returns true if the deployment is in a prod environment
         */
        this.isProd = new tapable_1.SyncWaterfallHook(['isProd']);
        /**
         * Perform any post processing, usually print the deploy link, save deployment info json, collect library files, etc.
         */
        this.postProcess = new tapable_1.AsyncSeriesHook();
    }
}
exports.DevDeployHooks = DevDeployHooks;
/**
 * @internal
 */
class DevDeployPlugin {
    constructor() {
        this.pluginName = "spfx-dev-deploy-plugin" /* DevDeployPlugin */;
    }
    get accessor() {
        if (!this._accessor) {
            this._accessor = {
                hooks: new DevDeployHooks()
            };
        }
        return this._accessor;
    }
    apply(heftSession, heftConfiguration) {
        heftSession.registerAction({
            actionName: 'dev-deploy',
            documentation: 'Deploy the current project, and optionally the whole repo, to a testing CDN.',
            parameters: {
                rush: {
                    kind: 'flag',
                    parameterLongName: '--rush',
                    description: 'If specified, deploy the whole rush repository instead of just the current project.'
                },
                maxRetries: {
                    kind: 'integer',
                    parameterLongName: '--max-retries',
                    description: 'Overrides the default maximum number of upload retries.'
                }
            },
            callback: async (parameters) => {
                const logger = heftSession.requestScopedLogger('dev-deploy-plugin');
                logger.terminal.writeLine('Starting DevDeploy...');
                this._installDefaultHooks();
                try {
                    await this._deployAsync({
                        useRush: parameters.rush,
                        maxRetries: parameters.maxRetries,
                        terminal: logger.terminal,
                        rootPath: heftConfiguration.buildFolder
                    });
                    logger.terminal.writeLine(node_core_library_1.Colors.green('DevDeploy completed successfully.'));
                }
                catch (e) {
                    logger.emitError(e);
                }
            }
        });
    }
    _installDefaultHooks() {
        const hooks = this.accessor.hooks;
        let devDeployProcessor;
        hooks.init.tapPromise("spfx-dev-deploy-plugin" /* DevDeployPlugin */, async (options) => {
            devDeployProcessor = await SpDevDeploy_1.SpDevDeploy.initializeAsync(options);
        });
        hooks.preProcess.tap("spfx-dev-deploy-plugin" /* DevDeployPlugin */, () => {
            devDeployProcessor.preProcess();
        });
        hooks.getContainerFolderName.tap("spfx-dev-deploy-plugin" /* DevDeployPlugin */, () => {
            return SpDevDeploy_1.SpDevDeploy.getDevDeployContainerDirectoryName();
        });
        hooks.isProd.tap("spfx-dev-deploy-plugin" /* DevDeployPlugin */, () => {
            return false;
        });
        hooks.getFiles.tapPromise("spfx-dev-deploy-plugin" /* DevDeployPlugin */, async () => {
            return await devDeployProcessor.getFiles();
        });
        hooks.postProcess.tapPromise("spfx-dev-deploy-plugin" /* DevDeployPlugin */, async () => {
            devDeployProcessor.postProcess();
        });
    }
    async _deployAsync(options) {
        const hooks = this.accessor.hooks;
        const accountName = hooks.getStorageAccountName.call();
        const sas = await hooks.getStorageSas.promise();
        const isProd = hooks.isProd.call(false);
        const containerName = hooks.getContainerName.call();
        const folderNameInContainer = hooks.getContainerFolderName.call();
        if (!accountName) {
            throw new Error('Azure storage account not set.');
        }
        if (!sas) {
            throw new Error('Azure storage account SAS not set.');
        }
        if (!containerName) {
            throw new Error('Azure container name not set.');
        }
        const deployConfig = {
            accountName,
            sas,
            isProd,
            containerName,
            folderNameInContainer,
            useRush: options.useRush,
            maxRetries: options.maxRetries || AzureUploader_1.AzureUploader.DEFAULT_AZURE_MAX_NUMBER_OF_RETRIES
        };
        await hooks.init.promise({
            isolateProjects: false,
            rootPath: options.rootPath,
            terminal: options.terminal,
            _additionalDirectoriesToInclude: deployConfig._additionalFoldersToInclude,
            devDeployConfig: deployConfig
        });
        hooks.preProcess.call();
        const deployData = await hooks.getFiles.promise();
        await DevDeployHelper_1.DevDeployHelper.deployFilesAsync(options.terminal, deployConfig, deployData);
        await hooks.postProcess.promise();
    }
}
exports.default = new DevDeployPlugin(); // tslint:disable-line:export-name
//# sourceMappingURL=DevDeployPlugin.js.map