"use strict";
/**
 * @file writePackage.ts
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * Writes a package xml object to disk, in both raw and zipped format
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeODCFile = exports.writeXmlFile = exports.writeIcon = exports.writeFeature = exports.cleanRawPackageDirectory = void 0;
/// <reference path="./node-zip.d.ts" />
/* tslint:disable:no-any */
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const JSZip = require("node-zip");
const node_core_library_1 = require("@rushstack/node-core-library");
const utilities_1 = require("../utilities");
/**
 * Writes the ISolutionXml object containing the solution package xml to the disk using provided config
 */
function writePackage(terminal, solution, config) {
    const zip = new JSZip();
    return cleanRawPackageDirectory(terminal, config)
        .then(() => Promise.all([
        writeODCFile(terminal, solution.manifest, config, zip),
        writeXmlFile(terminal, solution.relationships, config, zip),
        writeXmlFile(terminal, solution.contentTypesXml, config, zip),
        writeIcon(terminal, solution.icon, config, zip)
    ]
        .concat(solution.customFiles.map((customFile) => writeXmlFile(terminal, customFile, config, zip)))
        .concat(solution.features.map((feature) => writeFeature(terminal, feature, config, zip)))))
        .then(() => {
        return writeFile(terminal, config.paths.zippedPackage, zip.generate({ base64: false, compression: 'DEFLATE' }), 'binary');
    });
}
exports.default = writePackage;
/**
 * Ensures that the contents of config.paths.debugDir have been deleted
 */
async function cleanRawPackageDirectory(terminal, config) {
    await node_core_library_1.FileSystem.deleteFolderAsync(config.paths.debugDir);
    terminal.writeLine(`Cleaned ${config.paths.debugDir}`);
}
exports.cleanRawPackageDirectory = cleanRawPackageDirectory;
function writeFeature(terminal, feature, config, zip) {
    return Promise.all([writeODCFile(terminal, feature, config, zip), writeXmlFile(terminal, feature.config, config, zip)]
        .concat((feature.clientSideResources || []).map((resource) => writeXmlFile(terminal, resource, config, zip)))
        .concat(feature.assets.elementFiles.map((asset) => writeXmlFile(terminal, asset, config, zip)))
        .concat(feature.assets.elementManifests.map((asset) => writeXmlFile(terminal, asset, config, zip)))
        .concat(feature.assets.upgradeActions.map((asset) => writeXmlFile(terminal, asset, config, zip)))
        .concat(feature.components.map((component) => writeXmlFile(terminal, component, config, zip))));
}
exports.writeFeature = writeFeature;
/**
 * Write the app icon related files: The icon file itself, and the config.xml
 * If there is no icon it does nothing.
 * If the icon path is invalid, it throws an error.
 */
function writeIcon(terminal, icon, config, zip) {
    if (icon) {
        const filepath = path.join(config.paths.packageDir, icon.path);
        if (node_core_library_1.FileSystem.getStatistics(filepath).isFile()) {
            return Promise.all([
                // tslint:disable-next-line:no-floating-promises
                node_core_library_1.FileSystem.readFileToBufferAsync(filepath).then((data) => {
                    // tslint:disable-next-line:no-floating-promises
                    writeFileToPath(terminal, icon.path, data, config, zip);
                }),
                writeXmlFile(terminal, icon.config, config, zip),
                writeXmlFile(terminal, icon.relationships, config, zip)
            ]);
        }
        else {
            throw new Error(`Icon with path "${icon.path}" was not found.`);
        }
    }
}
exports.writeIcon = writeIcon;
function writeXmlFile(terminal, file, config, zip) {
    return writeFileToPath(terminal, file.filename, file.contents, config, zip);
}
exports.writeXmlFile = writeXmlFile;
function writeODCFile(terminal, file, config, zip) {
    return Promise.all([
        writeFileToPath(terminal, file.filename, file.contents, config, zip),
        writeXmlFile(terminal, file.relationships, config, zip)
    ]);
}
exports.writeODCFile = writeODCFile;
/**
 * Physically writes a file to disk, and adds to an in-memory zip package
 */
function writeFileToPath(terminal, filename, contents, config, zip) {
    const filepath = path.join(config.paths.debugDir, filename);
    return utilities_1.serial([() => writeFile(terminal, filepath, contents), () => addFileToZip(filename, contents, zip)]);
}
/**
 * Wraps fsx.writeFile in a promise
 */
async function writeFile(terminal, filename, contents, encoding) {
    node_core_library_1.FileSystem.ensureFolder(path.dirname(filename));
    fs.writeFileSync(filename, contents, encoding); // Unfortunately we need to use fs here to write a binary file
    terminal.writeLine(`Created file: ${filename}`);
}
/**
 * Adds a file to a zip package
 */
async function addFileToZip(filepath, content, zip) {
    const directories = filepath.split(path.sep);
    const file = directories.pop();
    for (const dir of directories) {
        zip = zip.folder(dir);
    }
    zip.file(file, content);
}
//# sourceMappingURL=writePackage.js.map