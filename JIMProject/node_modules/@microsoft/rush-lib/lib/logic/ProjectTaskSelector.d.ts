import { BuildCacheConfiguration } from '../api/BuildCacheConfiguration';
import { RushConfiguration } from '../api/RushConfiguration';
import { RushConfigurationProject } from '../api/RushConfigurationProject';
import { ProjectChangeAnalyzer } from './ProjectChangeAnalyzer';
import { TaskCollection } from './taskExecution/TaskCollection';
import { IPhase } from '../api/CommandLineConfiguration';
import { IRegisteredCustomParameter } from '../cli/scriptActions/BaseScriptAction';
export interface IProjectTaskSelectorOptions {
    rushConfiguration: RushConfiguration;
    buildCacheConfiguration: BuildCacheConfiguration | undefined;
    projectSelection: ReadonlySet<RushConfigurationProject>;
    isQuietMode: boolean;
    isDebugMode: boolean;
    isIncrementalBuildAllowed: boolean;
    projectChangeAnalyzer?: ProjectChangeAnalyzer;
    customParameters: IRegisteredCustomParameter[];
    phasesToRun: Iterable<string>;
    phases: Map<string, IPhase>;
}
/**
 * This class is responsible for:
 *  - based on to/from flags, solving the dependency graph and figuring out which projects need to be run
 *  - creating a ProjectBuilder for each project that needs to be built
 *  - registering the necessary ProjectBuilders with the TaskExecutionManager, which actually orchestrates execution
 */
export declare class ProjectTaskSelector {
    private readonly _options;
    private readonly _projectChangeAnalyzer;
    private readonly _phasesToRun;
    private readonly _phases;
    private readonly _customParametersByPhaseName;
    constructor(options: IProjectTaskSelectorOptions);
    static getScriptToRun(rushProject: RushConfigurationProject, commandToRun: string, customParameterValues: string[]): string | undefined;
    registerTasks(): TaskCollection;
    private _getPhaseByName;
    private _getPhaseDisplayNameForProject;
    private _getCustomParameterValuesForPhase;
    private static _getScriptCommand;
}
//# sourceMappingURL=ProjectTaskSelector.d.ts.map