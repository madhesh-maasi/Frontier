{"version":3,"file":"ProjectTaskSelector.js","sourceRoot":"","sources":["../../src/logic/ProjectTaskSelector.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { BuildCacheConfiguration } from '../api/BuildCacheConfiguration';\nimport { RushConfiguration } from '../api/RushConfiguration';\nimport { RushConfigurationProject } from '../api/RushConfigurationProject';\nimport { convertSlashesForWindows, ProjectTaskRunner } from './taskExecution/ProjectTaskRunner';\nimport { ProjectChangeAnalyzer } from './ProjectChangeAnalyzer';\nimport { TaskCollection } from './taskExecution/TaskCollection';\nimport { IPhase } from '../api/CommandLineConfiguration';\nimport { RushConstants } from './RushConstants';\nimport { IRegisteredCustomParameter } from '../cli/scriptActions/BaseScriptAction';\n\nexport interface IProjectTaskSelectorOptions {\n  rushConfiguration: RushConfiguration;\n  buildCacheConfiguration: BuildCacheConfiguration | undefined;\n  projectSelection: ReadonlySet<RushConfigurationProject>;\n  isQuietMode: boolean;\n  isDebugMode: boolean;\n  isIncrementalBuildAllowed: boolean;\n  projectChangeAnalyzer?: ProjectChangeAnalyzer;\n  customParameters: IRegisteredCustomParameter[];\n\n  phasesToRun: Iterable<string>;\n  phases: Map<string, IPhase>;\n}\n\n/**\n * This class is responsible for:\n *  - based on to/from flags, solving the dependency graph and figuring out which projects need to be run\n *  - creating a ProjectBuilder for each project that needs to be built\n *  - registering the necessary ProjectBuilders with the TaskExecutionManager, which actually orchestrates execution\n */\nexport class ProjectTaskSelector {\n  private readonly _options: IProjectTaskSelectorOptions;\n  private readonly _projectChangeAnalyzer: ProjectChangeAnalyzer;\n  private readonly _phasesToRun: Iterable<string>;\n  private readonly _phases: Map<string, IPhase>;\n  private readonly _customParametersByPhaseName: Map<string, string[]>;\n\n  public constructor(options: IProjectTaskSelectorOptions) {\n    this._options = options;\n    this._projectChangeAnalyzer =\n      options.projectChangeAnalyzer || new ProjectChangeAnalyzer(options.rushConfiguration);\n    this._phasesToRun = options.phasesToRun;\n    this._phases = options.phases;\n    this._customParametersByPhaseName = new Map();\n  }\n\n  public static getScriptToRun(\n    rushProject: RushConfigurationProject,\n    commandToRun: string,\n    customParameterValues: string[]\n  ): string | undefined {\n    const script: string | undefined = ProjectTaskSelector._getScriptCommand(rushProject, commandToRun);\n\n    if (script === undefined) {\n      return undefined;\n    }\n\n    if (!script) {\n      return '';\n    } else {\n      const taskCommand: string = `${script} ${customParameterValues.join(' ')}`;\n      return process.platform === 'win32' ? convertSlashesForWindows(taskCommand) : taskCommand;\n    }\n  }\n\n  public registerTasks(): TaskCollection {\n    const projects: ReadonlySet<RushConfigurationProject> = this._options.projectSelection;\n    const taskCollection: TaskCollection = new TaskCollection();\n\n    const selectedDependenciesCache: Map<RushConfigurationProject, Set<RushConfigurationProject>> = new Map();\n    function getSelectedDependencies(project: RushConfigurationProject): Set<RushConfigurationProject> {\n      let selectedDependencies: Set<RushConfigurationProject> | undefined =\n        selectedDependenciesCache.get(project);\n      if (selectedDependencies) {\n        return selectedDependencies;\n      }\n\n      selectedDependencies = new Set();\n      selectedDependenciesCache.set(project, selectedDependencies);\n\n      for (const dependency of project.dependencyProjects) {\n        if (projects.has(dependency)) {\n          // The tasks for this project are part of the set. Preserve dependency as-is\n          selectedDependencies.add(dependency);\n        } else {\n          // This project is not part of the set, but some of its dependencies could be.\n          for (const indirectDependency of getSelectedDependencies(dependency)) {\n            selectedDependencies.add(indirectDependency);\n          }\n        }\n      }\n\n      return selectedDependencies;\n    }\n\n    const taskDependencies: Map<string, Set<string>> = new Map();\n\n    // Register all tasks\n    // This currently does not correctly handle the scenario in which a phase is skipped.\n    // If that happens, the dependency graph will have an error due to a missing task.\n    for (const phaseName of this._phasesToRun) {\n      const phase: IPhase = this._getPhaseByName(phaseName);\n      for (const project of projects) {\n        const taskName: string = this._getPhaseDisplayNameForProject(phase, project);\n\n        const customParameterValues: string[] = this._getCustomParameterValuesForPhase(phase);\n        const commandToRun: string | undefined = ProjectTaskSelector.getScriptToRun(\n          project,\n          phase.name,\n          customParameterValues\n        );\n        if (commandToRun === undefined && !phase.ignoreMissingScript) {\n          throw new Error(\n            `The project '${project.packageName}' does not define a '${phase.name}' command in the 'scripts' section of its package.json`\n          );\n        }\n\n        taskCollection.addTask(\n          new ProjectTaskRunner({\n            rushProject: project,\n            taskName,\n            rushConfiguration: this._options.rushConfiguration,\n            buildCacheConfiguration: this._options.buildCacheConfiguration,\n            commandToRun: commandToRun || '',\n            isIncrementalBuildAllowed: this._options.isIncrementalBuildAllowed,\n            projectChangeAnalyzer: this._projectChangeAnalyzer,\n            phase\n          })\n        );\n\n        const dependencyTasks: Set<string> = new Set();\n        if (phase.dependencies?.self) {\n          for (const dependencyPhaseName of phase.dependencies.self) {\n            const dependencyPhase: IPhase = this._getPhaseByName(dependencyPhaseName);\n            const dependencyTaskName: string = this._getPhaseDisplayNameForProject(dependencyPhase, project);\n\n            dependencyTasks.add(dependencyTaskName);\n          }\n        }\n\n        if (phase.dependencies?.upstream) {\n          for (const dependencyPhaseName of phase.dependencies.upstream) {\n            const dependencyPhase: IPhase = this._getPhaseByName(dependencyPhaseName);\n            for (const dependencyProject of getSelectedDependencies(project)) {\n              const dependencyTaskName: string = this._getPhaseDisplayNameForProject(\n                dependencyPhase,\n                dependencyProject\n              );\n\n              dependencyTasks.add(dependencyTaskName);\n            }\n          }\n        }\n\n        taskDependencies.set(taskName, dependencyTasks);\n      }\n    }\n\n    for (const [taskName, dependencies] of taskDependencies) {\n      taskCollection.addDependencies(taskName, dependencies);\n    }\n\n    return taskCollection;\n  }\n\n  private _getPhaseByName(phaseName: string): IPhase {\n    const phase: IPhase | undefined = this._phases.get(phaseName);\n    if (!phase) {\n      throw new Error(`Phase ${phaseName} not found`);\n    }\n\n    return phase;\n  }\n\n  private _getPhaseDisplayNameForProject(phase: IPhase, project: RushConfigurationProject): string {\n    if (phase.isSynthetic) {\n      // Because this is a synthetic phase, just use the project name because there aren't any other phases\n      return project.packageName;\n    } else {\n      const phaseNameWithoutPrefix: string = phase.name.substring(RushConstants.phaseNamePrefix.length);\n      return `${project.packageName} (${phaseNameWithoutPrefix})`;\n    }\n  }\n\n  private _getCustomParameterValuesForPhase(phase: IPhase): string[] {\n    let customParameterValues: string[] | undefined = this._customParametersByPhaseName.get(phase.name);\n    if (customParameterValues === undefined) {\n      customParameterValues = [];\n      for (const { tsCommandLineParameter, parameter } of this._options.customParameters) {\n        if (phase.associatedParameters.has(parameter)) {\n          tsCommandLineParameter.appendToArgList(customParameterValues);\n        }\n      }\n\n      this._customParametersByPhaseName.set(phase.name, customParameterValues);\n    }\n\n    return customParameterValues;\n  }\n\n  private static _getScriptCommand(\n    rushProject: RushConfigurationProject,\n    script: string\n  ): string | undefined {\n    if (!rushProject.packageJson.scripts) {\n      return undefined;\n    }\n\n    const rawCommand: string = rushProject.packageJson.scripts[script];\n\n    if (rawCommand === undefined || rawCommand === null) {\n      return undefined;\n    }\n\n    return rawCommand;\n  }\n}\n"]}