{"version":3,"file":"Task.js","sourceRoot":"","sources":["../../../src/logic/taskExecution/Task.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;AAU3D;;;;GAIG;AACH,MAAa,IAAI;IA2Ef,YAAmB,MAAsB,EAAE,aAAyB;QA5DpE;;;WAGG;QACI,iBAAY,GAAc,IAAI,GAAG,EAAQ,CAAC;QAEjD;;WAEG;QACI,eAAU,GAAc,IAAI,GAAG,EAAQ,CAAC;QAoD7C,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,MAAM,GAAG,aAAa,CAAC;IAC9B,CAAC;IAED,IAAW,IAAI;QACb,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;IAC1B,CAAC;CACF;AAnFD,oBAmFC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { StdioSummarizer } from '@rushstack/terminal';\nimport { CollatedWriter } from '@rushstack/stream-collator';\n\nimport { Stopwatch } from '../../utilities/Stopwatch';\nimport { TaskStatus } from './TaskStatus';\nimport { TaskError } from './TaskError';\nimport { BaseTaskRunner } from './BaseTaskRunner';\n\n/**\n * The `Task` class is a node in the dependency graph of work that needs to be scheduled by the\n * `TaskExecutionManager`. Each `Task` has a `runner` member of type `BaseTaskRunner`, whose subclass\n * manages the actual operations for running a single task.\n */\nexport class Task {\n  /**\n   * When the scheduler is ready to process this `Task`, the `runner` implements the actual work of\n   * running the task.\n   */\n  public runner: BaseTaskRunner;\n\n  /**\n   * The current execution status of a task. Tasks start in the 'ready' state,\n   * but can be 'blocked' if an upstream task failed. It is 'executing' when\n   * the task is executing. Once execution is complete, it is either 'success' or\n   * 'failure'.\n   */\n  public status: TaskStatus;\n\n  /**\n   * A set of all dependencies which must be executed before this task is complete.\n   * When dependencies finish execution, they are removed from this list.\n   */\n  public dependencies: Set<Task> = new Set<Task>();\n\n  /**\n   * The inverse of dependencies, lists all projects which are directly dependent on this one.\n   */\n  public dependents: Set<Task> = new Set<Task>();\n\n  /**\n   * This number represents how far away this Task is from the furthest \"root\" project (i.e.\n   * a project with no dependents). This helps us to calculate the critical path (i.e. the\n   * longest chain of projects which must be executed in order, thereby limiting execution speed\n   * of the entire task tree.\n   *\n   * This number is calculated via a memoized recursive function, and when choosing the next\n   * task to execute, the task with the highest criticalPathLength is chosen.\n   *\n   * Example:\n   *        (0) A\n   *             \\\n   *          (1) B     C (0)         (applications)\n   *               \\   /|\\\n   *                \\ / | \\\n   *             (2) D  |  X (1)      (utilities)\n   *                    | / \\\n   *                    |/   \\\n   *                (2) Y     Z (2)   (other utilities)\n   *\n   * All roots (A & C) have a criticalPathLength of 0.\n   * B has a score of 1, since A depends on it.\n   * D has a score of 2, since we look at the longest chain (e.g D->B->A is longer than D->C)\n   * X has a score of 1, since the only package which depends on it is A\n   * Z has a score of 2, since only X depends on it, and X has a score of 1\n   * Y has a score of 2, since the chain Y->X->C is longer than Y->C\n   *\n   * The algorithm is implemented in TaskExecutionManager as _calculateCriticalPaths()\n   */\n  public criticalPathLength: number | undefined;\n\n  /**\n   * The error which occurred while executing this task, this is stored in case we need\n   * it later (for example to re-print errors at end of execution).\n   */\n  public error: TaskError | undefined;\n\n  /**\n   * The task writer which contains information from the output streams of this task\n   */\n  public collatedWriter!: CollatedWriter;\n\n  public stdioSummarizer!: StdioSummarizer;\n\n  /**\n   * The stopwatch which measures how long it takes the task to execute\n   */\n  public stopwatch!: Stopwatch;\n\n  public constructor(runner: BaseTaskRunner, initialStatus: TaskStatus) {\n    this.runner = runner;\n    this.status = initialStatus;\n  }\n\n  public get name(): string {\n    return this.runner.name;\n  }\n}\n"]}