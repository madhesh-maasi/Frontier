"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectWatcher = void 0;
const fs = __importStar(require("fs"));
const os = __importStar(require("os"));
const events_1 = require("events");
const node_core_library_1 = require("@rushstack/node-core-library");
const ProjectChangeAnalyzer_1 = require("./ProjectChangeAnalyzer");
/**
 * This class is for incrementally watching a set of projects in the repository for changes.
 *
 * We are manually using fs.watch() instead of `chokidar` because all we want from the file system watcher is a boolean
 * signal indicating that "at least 1 file in a watched project changed". We then defer to ProjectChangeAnalyzer (which
 * is responsible for change detection in all incremental builds) to determine what actually chanaged.
 *
 * Calling `waitForChange()` will return a promise that resolves when the package-deps of one or
 * more projects differ from the value the previous time it was invoked. The first time will always resolve with the full selection.
 */
class ProjectWatcher {
    constructor(options) {
        const { debounceMilliseconds = 1000, rushConfiguration, projectsToWatch, terminal } = options;
        this._debounceMilliseconds = debounceMilliseconds;
        this._rushConfiguration = rushConfiguration;
        this._projectsToWatch = projectsToWatch;
        this._terminal = terminal;
    }
    /**
     * Waits for a change to the package-deps of one or more of the selected projects, since the previous invocation.
     * Will return immediately the first time it is invoked, since no state has been recorded.
     * If no change is currently present, watches the source tree of all selected projects for file changes.
     */
    async waitForChange(onWatchingFiles) {
        const initialChangeResult = await this._computeChanged();
        // Ensure that the new state is recorded so that we don't loop infinitely
        this._commitChanges(initialChangeResult.state);
        if (initialChangeResult.changedProjects.size) {
            return initialChangeResult;
        }
        const previousState = initialChangeResult.state;
        const repoRoot = node_core_library_1.Path.convertToSlashes(this._rushConfiguration.rushJsonFolder);
        const pathsToWatch = new Set();
        // Node 12 supports the "recursive" parameter to fs.watch only on win32 and OSX
        // https://nodejs.org/docs/latest-v12.x/api/fs.html#fs_caveats
        const useNativeRecursiveWatch = os.platform() === 'win32' || os.platform() === 'darwin';
        for (const project of this._projectsToWatch) {
            const projectState = (await previousState._tryGetProjectDependenciesAsync(project, this._terminal));
            const projectFolder = project.projectRelativeFolder;
            // Watch files in the root of the project, or
            for (const fileName of projectState.keys()) {
                for (const pathToWatch of ProjectWatcher._enumeratePathsToWatch(fileName, projectFolder, useNativeRecursiveWatch)) {
                    pathsToWatch.add(`${repoRoot}/${pathToWatch}`);
                }
            }
        }
        const watchers = new Map();
        const watchedResult = await new Promise((resolve, reject) => {
            let timeout;
            let terminated = false;
            const resolveIfChanged = async () => {
                timeout = undefined;
                if (terminated) {
                    return;
                }
                try {
                    const result = await this._computeChanged();
                    // Need an async tick to allow for more file system events to be handled
                    process.nextTick(() => {
                        if (timeout) {
                            // If another file has changed, wait for another pass.
                            return;
                        }
                        this._commitChanges(result.state);
                        if (result.changedProjects.size) {
                            terminated = true;
                            resolve(result);
                        }
                    });
                }
                catch (err) {
                    // eslint-disable-next-line require-atomic-updates
                    terminated = true;
                    reject(err);
                }
            };
            const onError = (err) => {
                if (terminated) {
                    return;
                }
                terminated = true;
                reject(err);
            };
            const addWatcher = (watchedPath, listener) => {
                const watcher = fs.watch(watchedPath, {
                    encoding: 'utf-8',
                    recursive: useNativeRecursiveWatch
                }, listener);
                watchers.set(watchedPath, watcher);
                watcher.on('error', (err) => {
                    watchers.delete(watchedPath);
                    onError(err);
                });
            };
            const changeListener = (event, fileName) => {
                try {
                    if (terminated) {
                        return;
                    }
                    // Handling for added directories
                    if (!useNativeRecursiveWatch) {
                        const decodedName = fileName && fileName.toString();
                        const normalizedName = decodedName && node_core_library_1.Path.convertToSlashes(decodedName);
                        if (normalizedName && !watchers.has(normalizedName)) {
                            try {
                                const stat = node_core_library_1.FileSystem.getStatistics(fileName);
                                if (stat.isDirectory()) {
                                    addWatcher(normalizedName, changeListener);
                                }
                            }
                            catch (err) {
                                const code = err.code;
                                if (code !== 'ENOENT' && code !== 'ENOTDIR') {
                                    throw err;
                                }
                            }
                        }
                    }
                    // Use a timeout to debounce changes, e.g. bulk copying files into the directory while the watcher is running.
                    if (timeout) {
                        clearTimeout(timeout);
                    }
                    timeout = setTimeout(resolveIfChanged, this._debounceMilliseconds);
                }
                catch (err) {
                    terminated = true;
                    reject(err);
                }
            };
            for (const pathToWatch of pathsToWatch) {
                addWatcher(pathToWatch, changeListener);
            }
            if (onWatchingFiles) {
                onWatchingFiles();
            }
        });
        const closePromises = [];
        for (const [watchedPath, watcher] of watchers) {
            closePromises.push((0, events_1.once)(watcher, 'close').then(() => {
                watchers.delete(watchedPath);
            }));
            watcher.close();
        }
        await Promise.all(closePromises);
        return watchedResult;
    }
    /**
     * Determines which, if any, projects (within the selection) have new hashes for files that are not in .gitignore
     */
    async _computeChanged() {
        const state = new ProjectChangeAnalyzer_1.ProjectChangeAnalyzer(this._rushConfiguration);
        const previousState = this._previousState;
        if (!previousState) {
            return {
                changedProjects: this._projectsToWatch,
                state
            };
        }
        const changedProjects = new Set();
        for (const project of this._projectsToWatch) {
            const [previous, current] = await Promise.all([
                previousState._tryGetProjectDependenciesAsync(project, this._terminal),
                state._tryGetProjectDependenciesAsync(project, this._terminal)
            ]);
            if (ProjectWatcher._haveProjectDepsChanged(previous, current)) {
                // May need to detect if the nature of the change will break the process, e.g. changes to package.json
                changedProjects.add(project);
            }
        }
        return {
            changedProjects,
            state
        };
    }
    _commitChanges(state) {
        this._previousState = state;
        if (!this._initialState) {
            this._initialState = state;
        }
    }
    /**
     * Tests for inequality of the passed Maps. Order invariant.
     *
     * @returns `true` if the maps are different, `false` otherwise
     */
    static _haveProjectDepsChanged(prev, next) {
        if (prev.size !== next.size) {
            return true;
        }
        for (const [key, value] of prev) {
            if (next.get(key) !== value) {
                return true;
            }
        }
        return false;
    }
    static *_enumeratePathsToWatch(path, projectRelativeFolder, useNativeRecursiveWatch) {
        const rootSlashIndex = path.indexOf('/', projectRelativeFolder.length + 2);
        if (rootSlashIndex < 0) {
            yield path;
            return;
        }
        yield path.slice(0, rootSlashIndex);
        if (useNativeRecursiveWatch) {
            // Only need the root folder if fs.watch can be called with recursive: true
            return;
        }
        let slashIndex = path.lastIndexOf('/');
        while (slashIndex > rootSlashIndex) {
            yield path.slice(0, slashIndex);
            slashIndex = path.lastIndexOf('/', slashIndex - 1);
        }
    }
}
exports.ProjectWatcher = ProjectWatcher;
//# sourceMappingURL=ProjectWatcher.js.map