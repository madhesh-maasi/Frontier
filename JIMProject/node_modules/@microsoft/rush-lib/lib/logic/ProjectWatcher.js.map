{"version":3,"file":"ProjectWatcher.js","sourceRoot":"","sources":["../../src/logic/ProjectWatcher.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as fs from 'fs';\nimport * as os from 'os';\nimport { once } from 'events';\nimport { Path, ITerminal, FileSystemStats, FileSystem } from '@rushstack/node-core-library';\n\nimport { ProjectChangeAnalyzer } from './ProjectChangeAnalyzer';\nimport { RushConfiguration } from '../api/RushConfiguration';\nimport { RushConfigurationProject } from '../api/RushConfigurationProject';\n\nexport interface IProjectWatcherOptions {\n  debounceMilliseconds?: number;\n  rushConfiguration: RushConfiguration;\n  projectsToWatch: ReadonlySet<RushConfigurationProject>;\n  terminal: ITerminal;\n}\n\nexport interface IProjectChangeResult {\n  /**\n   * The set of projects that have changed since the last iteration\n   */\n  changedProjects: ReadonlySet<RushConfigurationProject>;\n  /**\n   * Contains the git hashes for all tracked files in the repo\n   */\n  state: ProjectChangeAnalyzer;\n}\n\n/**\n * This class is for incrementally watching a set of projects in the repository for changes.\n *\n * We are manually using fs.watch() instead of `chokidar` because all we want from the file system watcher is a boolean\n * signal indicating that \"at least 1 file in a watched project changed\". We then defer to ProjectChangeAnalyzer (which\n * is responsible for change detection in all incremental builds) to determine what actually chanaged.\n *\n * Calling `waitForChange()` will return a promise that resolves when the package-deps of one or\n * more projects differ from the value the previous time it was invoked. The first time will always resolve with the full selection.\n */\nexport class ProjectWatcher {\n  private readonly _debounceMilliseconds: number;\n  private readonly _rushConfiguration: RushConfiguration;\n  private readonly _projectsToWatch: ReadonlySet<RushConfigurationProject>;\n  private readonly _terminal: ITerminal;\n\n  private _initialState: ProjectChangeAnalyzer | undefined;\n  private _previousState: ProjectChangeAnalyzer | undefined;\n\n  public constructor(options: IProjectWatcherOptions) {\n    const { debounceMilliseconds = 1000, rushConfiguration, projectsToWatch, terminal } = options;\n\n    this._debounceMilliseconds = debounceMilliseconds;\n    this._rushConfiguration = rushConfiguration;\n    this._projectsToWatch = projectsToWatch;\n    this._terminal = terminal;\n  }\n\n  /**\n   * Waits for a change to the package-deps of one or more of the selected projects, since the previous invocation.\n   * Will return immediately the first time it is invoked, since no state has been recorded.\n   * If no change is currently present, watches the source tree of all selected projects for file changes.\n   */\n  public async waitForChange(onWatchingFiles?: () => void): Promise<IProjectChangeResult> {\n    const initialChangeResult: IProjectChangeResult = await this._computeChanged();\n    // Ensure that the new state is recorded so that we don't loop infinitely\n    this._commitChanges(initialChangeResult.state);\n    if (initialChangeResult.changedProjects.size) {\n      return initialChangeResult;\n    }\n\n    const previousState: ProjectChangeAnalyzer = initialChangeResult.state;\n    const repoRoot: string = Path.convertToSlashes(this._rushConfiguration.rushJsonFolder);\n\n    const pathsToWatch: Set<string> = new Set();\n\n    // Node 12 supports the \"recursive\" parameter to fs.watch only on win32 and OSX\n    // https://nodejs.org/docs/latest-v12.x/api/fs.html#fs_caveats\n    const useNativeRecursiveWatch: boolean = os.platform() === 'win32' || os.platform() === 'darwin';\n\n    for (const project of this._projectsToWatch) {\n      const projectState: Map<string, string> = (await previousState._tryGetProjectDependenciesAsync(\n        project,\n        this._terminal\n      ))!;\n      const projectFolder: string = project.projectRelativeFolder;\n      // Watch files in the root of the project, or\n      for (const fileName of projectState.keys()) {\n        for (const pathToWatch of ProjectWatcher._enumeratePathsToWatch(\n          fileName,\n          projectFolder,\n          useNativeRecursiveWatch\n        )) {\n          pathsToWatch.add(`${repoRoot}/${pathToWatch}`);\n        }\n      }\n    }\n\n    const watchers: Map<string, fs.FSWatcher> = new Map();\n\n    const watchedResult: IProjectChangeResult = await new Promise(\n      (resolve: (result: IProjectChangeResult) => void, reject: (err: Error) => void) => {\n        let timeout: NodeJS.Timeout | undefined;\n        let terminated: boolean = false;\n\n        const resolveIfChanged = async (): Promise<void> => {\n          timeout = undefined;\n          if (terminated) {\n            return;\n          }\n\n          try {\n            const result: IProjectChangeResult = await this._computeChanged();\n\n            // Need an async tick to allow for more file system events to be handled\n            process.nextTick(() => {\n              if (timeout) {\n                // If another file has changed, wait for another pass.\n                return;\n              }\n\n              this._commitChanges(result.state);\n\n              if (result.changedProjects.size) {\n                terminated = true;\n                resolve(result);\n              }\n            });\n          } catch (err) {\n            // eslint-disable-next-line require-atomic-updates\n            terminated = true;\n            reject(err as NodeJS.ErrnoException);\n          }\n        };\n\n        const onError = (err: Error): void => {\n          if (terminated) {\n            return;\n          }\n\n          terminated = true;\n          reject(err);\n        };\n\n        const addWatcher = (\n          watchedPath: string,\n          listener: (event: string, fileName: string) => void\n        ): void => {\n          const watcher: fs.FSWatcher = fs.watch(\n            watchedPath,\n            {\n              encoding: 'utf-8',\n              recursive: useNativeRecursiveWatch\n            },\n            listener\n          );\n          watchers.set(watchedPath, watcher);\n          watcher.on('error', (err) => {\n            watchers.delete(watchedPath);\n            onError(err);\n          });\n        };\n\n        const changeListener = (event: string, fileName: string): void => {\n          try {\n            if (terminated) {\n              return;\n            }\n\n            // Handling for added directories\n            if (!useNativeRecursiveWatch) {\n              const decodedName: string = fileName && fileName.toString();\n              const normalizedName: string = decodedName && Path.convertToSlashes(decodedName);\n\n              if (normalizedName && !watchers.has(normalizedName)) {\n                try {\n                  const stat: FileSystemStats = FileSystem.getStatistics(fileName);\n                  if (stat.isDirectory()) {\n                    addWatcher(normalizedName, changeListener);\n                  }\n                } catch (err) {\n                  const code: string | undefined = (err as NodeJS.ErrnoException).code;\n\n                  if (code !== 'ENOENT' && code !== 'ENOTDIR') {\n                    throw err;\n                  }\n                }\n              }\n            }\n\n            // Use a timeout to debounce changes, e.g. bulk copying files into the directory while the watcher is running.\n            if (timeout) {\n              clearTimeout(timeout);\n            }\n\n            timeout = setTimeout(resolveIfChanged, this._debounceMilliseconds);\n          } catch (err) {\n            terminated = true;\n            reject(err as NodeJS.ErrnoException);\n          }\n        };\n\n        for (const pathToWatch of pathsToWatch) {\n          addWatcher(pathToWatch, changeListener);\n        }\n\n        if (onWatchingFiles) {\n          onWatchingFiles();\n        }\n      }\n    );\n\n    const closePromises: Promise<void>[] = [];\n    for (const [watchedPath, watcher] of watchers) {\n      closePromises.push(\n        once(watcher, 'close').then(() => {\n          watchers.delete(watchedPath);\n        })\n      );\n      watcher.close();\n    }\n\n    await Promise.all(closePromises);\n\n    return watchedResult;\n  }\n\n  /**\n   * Determines which, if any, projects (within the selection) have new hashes for files that are not in .gitignore\n   */\n  private async _computeChanged(): Promise<IProjectChangeResult> {\n    const state: ProjectChangeAnalyzer = new ProjectChangeAnalyzer(this._rushConfiguration);\n\n    const previousState: ProjectChangeAnalyzer | undefined = this._previousState;\n\n    if (!previousState) {\n      return {\n        changedProjects: this._projectsToWatch,\n        state\n      };\n    }\n\n    const changedProjects: Set<RushConfigurationProject> = new Set();\n    for (const project of this._projectsToWatch) {\n      const [previous, current] = await Promise.all([\n        previousState._tryGetProjectDependenciesAsync(project, this._terminal),\n        state._tryGetProjectDependenciesAsync(project, this._terminal)\n      ]);\n\n      if (ProjectWatcher._haveProjectDepsChanged(previous!, current!)) {\n        // May need to detect if the nature of the change will break the process, e.g. changes to package.json\n        changedProjects.add(project);\n      }\n    }\n\n    return {\n      changedProjects,\n      state\n    };\n  }\n\n  private _commitChanges(state: ProjectChangeAnalyzer): void {\n    this._previousState = state;\n    if (!this._initialState) {\n      this._initialState = state;\n    }\n  }\n\n  /**\n   * Tests for inequality of the passed Maps. Order invariant.\n   *\n   * @returns `true` if the maps are different, `false` otherwise\n   */\n  private static _haveProjectDepsChanged(prev: Map<string, string>, next: Map<string, string>): boolean {\n    if (prev.size !== next.size) {\n      return true;\n    }\n\n    for (const [key, value] of prev) {\n      if (next.get(key) !== value) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private static *_enumeratePathsToWatch(\n    path: string,\n    projectRelativeFolder: string,\n    useNativeRecursiveWatch: boolean\n  ): Iterable<string> {\n    const rootSlashIndex: number = path.indexOf('/', projectRelativeFolder.length + 2);\n\n    if (rootSlashIndex < 0) {\n      yield path;\n      return;\n    }\n\n    yield path.slice(0, rootSlashIndex);\n\n    if (useNativeRecursiveWatch) {\n      // Only need the root folder if fs.watch can be called with recursive: true\n      return;\n    }\n\n    let slashIndex: number = path.lastIndexOf('/');\n    while (slashIndex > rootSlashIndex) {\n      yield path.slice(0, slashIndex);\n      slashIndex = path.lastIndexOf('/', slashIndex - 1);\n    }\n  }\n}\n"]}