"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProjectTaskSelector = void 0;
const ProjectTaskRunner_1 = require("./taskExecution/ProjectTaskRunner");
const ProjectChangeAnalyzer_1 = require("./ProjectChangeAnalyzer");
const TaskCollection_1 = require("./taskExecution/TaskCollection");
const RushConstants_1 = require("./RushConstants");
/**
 * This class is responsible for:
 *  - based on to/from flags, solving the dependency graph and figuring out which projects need to be run
 *  - creating a ProjectBuilder for each project that needs to be built
 *  - registering the necessary ProjectBuilders with the TaskExecutionManager, which actually orchestrates execution
 */
class ProjectTaskSelector {
    constructor(options) {
        this._options = options;
        this._projectChangeAnalyzer =
            options.projectChangeAnalyzer || new ProjectChangeAnalyzer_1.ProjectChangeAnalyzer(options.rushConfiguration);
        this._phasesToRun = options.phasesToRun;
        this._phases = options.phases;
        this._customParametersByPhaseName = new Map();
    }
    static getScriptToRun(rushProject, commandToRun, customParameterValues) {
        const script = ProjectTaskSelector._getScriptCommand(rushProject, commandToRun);
        if (script === undefined) {
            return undefined;
        }
        if (!script) {
            return '';
        }
        else {
            const taskCommand = `${script} ${customParameterValues.join(' ')}`;
            return process.platform === 'win32' ? (0, ProjectTaskRunner_1.convertSlashesForWindows)(taskCommand) : taskCommand;
        }
    }
    registerTasks() {
        var _a, _b;
        const projects = this._options.projectSelection;
        const taskCollection = new TaskCollection_1.TaskCollection();
        const selectedDependenciesCache = new Map();
        function getSelectedDependencies(project) {
            let selectedDependencies = selectedDependenciesCache.get(project);
            if (selectedDependencies) {
                return selectedDependencies;
            }
            selectedDependencies = new Set();
            selectedDependenciesCache.set(project, selectedDependencies);
            for (const dependency of project.dependencyProjects) {
                if (projects.has(dependency)) {
                    // The tasks for this project are part of the set. Preserve dependency as-is
                    selectedDependencies.add(dependency);
                }
                else {
                    // This project is not part of the set, but some of its dependencies could be.
                    for (const indirectDependency of getSelectedDependencies(dependency)) {
                        selectedDependencies.add(indirectDependency);
                    }
                }
            }
            return selectedDependencies;
        }
        const taskDependencies = new Map();
        // Register all tasks
        // This currently does not correctly handle the scenario in which a phase is skipped.
        // If that happens, the dependency graph will have an error due to a missing task.
        for (const phaseName of this._phasesToRun) {
            const phase = this._getPhaseByName(phaseName);
            for (const project of projects) {
                const taskName = this._getPhaseDisplayNameForProject(phase, project);
                const customParameterValues = this._getCustomParameterValuesForPhase(phase);
                const commandToRun = ProjectTaskSelector.getScriptToRun(project, phase.name, customParameterValues);
                if (commandToRun === undefined && !phase.ignoreMissingScript) {
                    throw new Error(`The project '${project.packageName}' does not define a '${phase.name}' command in the 'scripts' section of its package.json`);
                }
                taskCollection.addTask(new ProjectTaskRunner_1.ProjectTaskRunner({
                    rushProject: project,
                    taskName,
                    rushConfiguration: this._options.rushConfiguration,
                    buildCacheConfiguration: this._options.buildCacheConfiguration,
                    commandToRun: commandToRun || '',
                    isIncrementalBuildAllowed: this._options.isIncrementalBuildAllowed,
                    projectChangeAnalyzer: this._projectChangeAnalyzer,
                    phase
                }));
                const dependencyTasks = new Set();
                if ((_a = phase.dependencies) === null || _a === void 0 ? void 0 : _a.self) {
                    for (const dependencyPhaseName of phase.dependencies.self) {
                        const dependencyPhase = this._getPhaseByName(dependencyPhaseName);
                        const dependencyTaskName = this._getPhaseDisplayNameForProject(dependencyPhase, project);
                        dependencyTasks.add(dependencyTaskName);
                    }
                }
                if ((_b = phase.dependencies) === null || _b === void 0 ? void 0 : _b.upstream) {
                    for (const dependencyPhaseName of phase.dependencies.upstream) {
                        const dependencyPhase = this._getPhaseByName(dependencyPhaseName);
                        for (const dependencyProject of getSelectedDependencies(project)) {
                            const dependencyTaskName = this._getPhaseDisplayNameForProject(dependencyPhase, dependencyProject);
                            dependencyTasks.add(dependencyTaskName);
                        }
                    }
                }
                taskDependencies.set(taskName, dependencyTasks);
            }
        }
        for (const [taskName, dependencies] of taskDependencies) {
            taskCollection.addDependencies(taskName, dependencies);
        }
        return taskCollection;
    }
    _getPhaseByName(phaseName) {
        const phase = this._phases.get(phaseName);
        if (!phase) {
            throw new Error(`Phase ${phaseName} not found`);
        }
        return phase;
    }
    _getPhaseDisplayNameForProject(phase, project) {
        if (phase.isSynthetic) {
            // Because this is a synthetic phase, just use the project name because there aren't any other phases
            return project.packageName;
        }
        else {
            const phaseNameWithoutPrefix = phase.name.substring(RushConstants_1.RushConstants.phaseNamePrefix.length);
            return `${project.packageName} (${phaseNameWithoutPrefix})`;
        }
    }
    _getCustomParameterValuesForPhase(phase) {
        let customParameterValues = this._customParametersByPhaseName.get(phase.name);
        if (customParameterValues === undefined) {
            customParameterValues = [];
            for (const { tsCommandLineParameter, parameter } of this._options.customParameters) {
                if (phase.associatedParameters.has(parameter)) {
                    tsCommandLineParameter.appendToArgList(customParameterValues);
                }
            }
            this._customParametersByPhaseName.set(phase.name, customParameterValues);
        }
        return customParameterValues;
    }
    static _getScriptCommand(rushProject, script) {
        if (!rushProject.packageJson.scripts) {
            return undefined;
        }
        const rawCommand = rushProject.packageJson.scripts[script];
        if (rawCommand === undefined || rawCommand === null) {
            return undefined;
        }
        return rawCommand;
    }
}
exports.ProjectTaskSelector = ProjectTaskSelector;
//# sourceMappingURL=ProjectTaskSelector.js.map