"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommandLineConfiguration = void 0;
const path = __importStar(require("path"));
const node_core_library_1 = require("@rushstack/node-core-library");
const RushConstants_1 = require("../logic/RushConstants");
const DEFAULT_BUILD_COMMAND_JSON = {
    commandKind: RushConstants_1.RushConstants.bulkCommandKind,
    name: RushConstants_1.RushConstants.buildCommandName,
    summary: "Build all projects that haven't been built, or have changed since they were last built.",
    description: 'This command is similar to "rush rebuild", except that "rush build" performs' +
        ' an incremental build. In other words, it only builds projects whose source files have changed' +
        ' since the last successful build. The analysis requires a Git working tree, and only considers' +
        ' source files that are tracked by Git and whose path is under the project folder. (For more details' +
        ' about this algorithm, see the documentation for the "package-deps-hash" NPM package.) The incremental' +
        ' build state is tracked in a per-project folder called ".rush/temp" which should NOT be added to Git. The' +
        ' build command is tracked by the "arguments" field in the "package-deps_build.json" file contained' +
        ' therein; a full rebuild is forced whenever the command has changed (e.g. "--production" or not).',
    enableParallelism: true,
    ignoreMissingScript: false,
    ignoreDependencyOrder: false,
    incremental: true,
    allowWarningsInSuccessfulBuild: false,
    safeForSimultaneousRushProcesses: false
};
const DEFAULT_REBUILD_COMMAND_JSON = {
    commandKind: RushConstants_1.RushConstants.bulkCommandKind,
    name: RushConstants_1.RushConstants.rebuildCommandName,
    summary: 'Clean and rebuild the entire set of projects.',
    description: 'This command assumes that the package.json file for each project contains' +
        ' a "scripts" entry for "npm run build" that performs a full clean build.' +
        ' Rush invokes this script to build each project that is registered in rush.json.' +
        ' Projects are built in parallel where possible, but always respecting the dependency' +
        ' graph for locally linked projects.  The number of simultaneous processes will be' +
        ' based on the number of machine cores unless overridden by the --parallelism flag.' +
        ' (For an incremental build, see "rush build" instead of "rush rebuild".)',
    enableParallelism: true,
    ignoreMissingScript: false,
    ignoreDependencyOrder: false,
    incremental: false,
    allowWarningsInSuccessfulBuild: false,
    safeForSimultaneousRushProcesses: false
};
/**
 * Custom Commands and Options for the Rush Command Line
 */
class CommandLineConfiguration {
    /**
     * Use CommandLineConfiguration.loadFromFile()
     *
     * @internal
     */
    constructor(commandLineJson) {
        var _a, _b;
        this.commands = new Map();
        this.phases = new Map();
        this.parameters = [];
        /**
         * These path will be prepended to the PATH environment variable
         */
        this._additionalPathFolders = [];
        /**
         * A map of bulk command names to their corresponding synthetic phase identifiers
         */
        this._syntheticPhasesNamesByTranslatedBulkCommandName = new Map();
        if (commandLineJson === null || commandLineJson === void 0 ? void 0 : commandLineJson.phases) {
            const phaseNameRegexp = new RegExp(`^${RushConstants_1.RushConstants.phaseNamePrefix}[a-z][a-z0-9]*([-][a-z0-9]+)*$`);
            for (const phase of commandLineJson.phases) {
                if (this.phases.has(phase.name)) {
                    throw new Error(`In ${RushConstants_1.RushConstants.commandLineFilename}, the phase "${phase.name}" is specified ` +
                        'more than once.');
                }
                if (!phase.name.match(phaseNameRegexp)) {
                    throw new Error(`In ${RushConstants_1.RushConstants.commandLineFilename}, the phase "${phase.name}"'s name ` +
                        'is not a valid phase name. Phase names must begin with the ' +
                        `required prefix "${RushConstants_1.RushConstants.phaseNamePrefix}" followed by a name containing ` +
                        'lowercase letters, numbers, or hyphens. The name must start with a letter and ' +
                        'must not end with a hyphen.');
                }
                this.phases.set(phase.name, Object.assign(Object.assign({}, phase), { isSynthetic: false, logFilenameIdentifier: this._normalizeNameForLogFilenameIdentifiers(phase.name), associatedParameters: new Set() }));
            }
        }
        for (const phase of this.phases.values()) {
            if ((_a = phase.dependencies) === null || _a === void 0 ? void 0 : _a.self) {
                for (const dependencyName of phase.dependencies.self) {
                    const dependency = this.phases.get(dependencyName);
                    if (!dependency) {
                        throw new Error(`In ${RushConstants_1.RushConstants.commandLineFilename}, in the phase "${phase.name}", the self ` +
                            `dependency phase "${dependencyName}" does not exist.`);
                    }
                }
            }
            if ((_b = phase.dependencies) === null || _b === void 0 ? void 0 : _b.upstream) {
                for (const dependency of phase.dependencies.upstream) {
                    if (!this.phases.has(dependency)) {
                        throw new Error(`In ${RushConstants_1.RushConstants.commandLineFilename}, in the phase "${phase.name}", ` +
                            `the upstream dependency phase "${dependency}" does not exist.`);
                    }
                }
            }
            this._checkForPhaseSelfCycles(phase);
        }
        let buildCommandPhases;
        if (commandLineJson === null || commandLineJson === void 0 ? void 0 : commandLineJson.commands) {
            for (const command of commandLineJson.commands) {
                if (this.commands.has(command.name)) {
                    throw new Error(`In ${RushConstants_1.RushConstants.commandLineFilename}, the command "${command.name}" is specified ` +
                        'more than once.');
                }
                let normalizedCommand;
                switch (command.commandKind) {
                    case RushConstants_1.RushConstants.phasedCommandKind: {
                        normalizedCommand = Object.assign(Object.assign({}, command), { isSynthetic: false, associatedParameters: new Set() });
                        for (const phaseName of normalizedCommand.phases) {
                            if (!this.phases.has(phaseName)) {
                                throw new Error(`In ${RushConstants_1.RushConstants.commandLineFilename}, in the "phases" property of the ` +
                                    `"${normalizedCommand.name}" command, the phase "${phaseName}" does not exist.`);
                            }
                        }
                        if (normalizedCommand.skipPhasesForCommand) {
                            for (const phaseName of normalizedCommand.skipPhasesForCommand) {
                                if (!this.phases.has(phaseName)) {
                                    throw new Error(`In ${RushConstants_1.RushConstants.commandLineFilename}, in the "skipPhasesForCommand" property of the ` +
                                        `"${normalizedCommand.name}" command, the phase ` +
                                        `"${phaseName}" does not exist.`);
                                }
                            }
                        }
                        break;
                    }
                    case RushConstants_1.RushConstants.globalCommandKind: {
                        normalizedCommand = Object.assign(Object.assign({}, command), { associatedParameters: new Set() });
                        break;
                    }
                    case RushConstants_1.RushConstants.bulkCommandKind: {
                        // Translate the bulk command into a phased command
                        normalizedCommand = this._translateBulkCommandToPhasedCommand(command);
                        break;
                    }
                }
                if (normalizedCommand.name === RushConstants_1.RushConstants.buildCommandName ||
                    normalizedCommand.name === RushConstants_1.RushConstants.rebuildCommandName) {
                    if (normalizedCommand.commandKind === RushConstants_1.RushConstants.globalCommandKind) {
                        throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a command "${normalizedCommand.name}" using ` +
                            `the command kind "${RushConstants_1.RushConstants.globalCommandKind}". This command can only be designated as a command ` +
                            `kind "${RushConstants_1.RushConstants.bulkCommandKind}" or "${RushConstants_1.RushConstants.phasedCommandKind}".`);
                    }
                    else if (command.safeForSimultaneousRushProcesses) {
                        throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a command "${normalizedCommand.name}" using ` +
                            `"safeForSimultaneousRushProcesses=true". This configuration is not supported for "${normalizedCommand.name}".`);
                    }
                    else if (normalizedCommand.name === RushConstants_1.RushConstants.buildCommandName) {
                        // Record the build command phases in case we need to construct a synthetic "rebuild" command
                        buildCommandPhases = normalizedCommand.phases;
                    }
                }
                this.commands.set(normalizedCommand.name, normalizedCommand);
            }
        }
        let buildCommand = this.commands.get(RushConstants_1.RushConstants.buildCommandName);
        if (!buildCommand) {
            // If the build command was not specified in the config file, add the default build command
            buildCommand = this._translateBulkCommandToPhasedCommand(DEFAULT_BUILD_COMMAND_JSON);
            buildCommand.disableBuildCache = DEFAULT_BUILD_COMMAND_JSON.disableBuildCache;
            buildCommandPhases = buildCommand.phases;
            this.commands.set(buildCommand.name, buildCommand);
        }
        if (!this.commands.has(RushConstants_1.RushConstants.rebuildCommandName)) {
            // If a rebuild command was not specified in the config file, add the default rebuild command
            if (!buildCommandPhases) {
                throw new Error(`Phases for the "${RushConstants_1.RushConstants.buildCommandName}" were not found.`);
            }
            const rebuildCommand = Object.assign(Object.assign({}, DEFAULT_REBUILD_COMMAND_JSON), { commandKind: RushConstants_1.RushConstants.phasedCommandKind, isSynthetic: true, phases: buildCommandPhases, disableBuildCache: DEFAULT_REBUILD_COMMAND_JSON.disableBuildCache, associatedParameters: buildCommand.associatedParameters // rebuild should share build's parameters in this case
             });
            this.commands.set(rebuildCommand.name, rebuildCommand);
        }
        if (commandLineJson === null || commandLineJson === void 0 ? void 0 : commandLineJson.parameters) {
            for (const parameter of commandLineJson.parameters) {
                const normalizedParameter = Object.assign(Object.assign({}, parameter), { associatedPhases: parameter.associatedPhases ? [...parameter.associatedPhases] : [], associatedCommands: parameter.associatedCommands ? [...parameter.associatedCommands] : [] });
                this.parameters.push(normalizedParameter);
                let parameterHasAssociatedPhases = false;
                // Do some basic validation
                switch (normalizedParameter.parameterKind) {
                    case 'flag': {
                        const addPhasesToCommandSet = new Set();
                        if (normalizedParameter.addPhasesToCommand) {
                            for (const phaseName of normalizedParameter.addPhasesToCommand) {
                                addPhasesToCommandSet.add(phaseName);
                                const phase = this.phases.get(phaseName);
                                if (!phase || phase.isSynthetic) {
                                    throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a parameter "${normalizedParameter.longName}" ` +
                                        `that lists phase "${phaseName}" in its "addPhasesToCommand" ` +
                                        'property that does not exist.');
                                }
                                parameterHasAssociatedPhases = true;
                            }
                        }
                        if (normalizedParameter.skipPhasesForCommand) {
                            for (const phaseName of normalizedParameter.skipPhasesForCommand) {
                                const phase = this.phases.get(phaseName);
                                if (!phase || phase.isSynthetic) {
                                    throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a parameter "${normalizedParameter.longName}" ` +
                                        `that lists phase "${phaseName}" in its skipPhasesForCommand" ` +
                                        'property that does not exist.');
                                }
                                else if (addPhasesToCommandSet.has(phaseName)) {
                                    throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a parameter "${normalizedParameter.longName}" ` +
                                        `that lists phase "${phaseName}" in both its "addPhasesToCommand" ` +
                                        'and "skipPhasesForCommand" properties.');
                                }
                                parameterHasAssociatedPhases = true;
                            }
                        }
                        break;
                    }
                    case 'choice': {
                        const alternativeNames = normalizedParameter.alternatives.map((x) => x.name);
                        if (normalizedParameter.defaultValue &&
                            alternativeNames.indexOf(normalizedParameter.defaultValue) < 0) {
                            throw new Error(`In ${RushConstants_1.RushConstants.commandLineFilename}, the parameter "${normalizedParameter.longName}",` +
                                ` specifies a default value "${normalizedParameter.defaultValue}"` +
                                ` which is not one of the defined alternatives: "${alternativeNames.toString()}"`);
                        }
                        break;
                    }
                }
                let parameterHasAssociatedCommands = false;
                let parameterIsOnlyAssociatedWithPhasedCommands = true;
                if (normalizedParameter.associatedCommands) {
                    for (const associatedCommandName of normalizedParameter.associatedCommands) {
                        const syntheticPhaseName = this._syntheticPhasesNamesByTranslatedBulkCommandName.get(associatedCommandName);
                        if (syntheticPhaseName) {
                            // If this parameter was associated with a bulk command, include the association
                            // with the synthetic phase
                            normalizedParameter.associatedPhases.push(syntheticPhaseName);
                        }
                        const associatedCommand = this.commands.get(associatedCommandName);
                        if (!associatedCommand) {
                            throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a parameter "${normalizedParameter.longName}" ` +
                                `that is associated with a command "${associatedCommandName}" that does not exist or does ` +
                                'not support custom parameters.');
                        }
                        else {
                            associatedCommand.associatedParameters.add(normalizedParameter);
                            parameterHasAssociatedCommands = true;
                            if (associatedCommand.commandKind !== RushConstants_1.RushConstants.phasedCommandKind) {
                                parameterIsOnlyAssociatedWithPhasedCommands = false;
                            }
                        }
                    }
                }
                if (normalizedParameter.associatedPhases) {
                    for (const associatedPhaseName of normalizedParameter.associatedPhases) {
                        const associatedPhase = this.phases.get(associatedPhaseName);
                        if (!associatedPhase) {
                            throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a parameter "${normalizedParameter.longName}" ` +
                                `that is associated with a phase "${associatedPhaseName}" that does not exist.`);
                        }
                        else {
                            associatedPhase.associatedParameters.add(normalizedParameter);
                            parameterHasAssociatedPhases = true;
                        }
                    }
                }
                if (!parameterHasAssociatedCommands) {
                    throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a parameter "${normalizedParameter.longName}"` +
                        ` that lists no associated commands.`);
                }
                if (parameterIsOnlyAssociatedWithPhasedCommands && !parameterHasAssociatedPhases) {
                    throw new Error(`${RushConstants_1.RushConstants.commandLineFilename} defines a parameter "${normalizedParameter.longName}" ` +
                        `that is only associated with phased commands, but lists no associated phases.`);
                }
            }
        }
    }
    _checkForPhaseSelfCycles(phase, checkedPhases = new Set()) {
        var _a;
        const phaseSelfDependencies = (_a = phase.dependencies) === null || _a === void 0 ? void 0 : _a.self;
        if (phaseSelfDependencies) {
            for (const dependencyName of phaseSelfDependencies) {
                if (checkedPhases.has(dependencyName)) {
                    const dependencyNameForError = typeof dependencyName === 'string' ? dependencyName : '<synthetic phase>';
                    throw new Error(`In ${RushConstants_1.RushConstants.commandLineFilename}, there exists a cycle within the ` +
                        `set of ${dependencyNameForError} dependencies: ${Array.from(checkedPhases).join(', ')}`);
                }
                else {
                    checkedPhases.add(dependencyName);
                    const dependency = this.phases.get(dependencyName);
                    if (!dependency) {
                        return; // Ignore, we check for this separately
                    }
                    else {
                        if (phaseSelfDependencies.length > 1) {
                            this._checkForPhaseSelfCycles(dependency, 
                            // Clone the set of checked phases if there are multiple branches we need to check
                            new Set(checkedPhases));
                        }
                        else {
                            this._checkForPhaseSelfCycles(dependency, checkedPhases);
                        }
                    }
                }
            }
        }
    }
    /**
     * Loads the configuration from the specified file and applies any omitted default build
     * settings.  If the file does not exist, then an empty default instance is returned.
     * If the file contains errors, then an exception is thrown.
     */
    static loadFromFileOrDefault(jsonFilename) {
        let commandLineJson = undefined;
        if (jsonFilename && node_core_library_1.FileSystem.exists(jsonFilename)) {
            commandLineJson = node_core_library_1.JsonFile.load(jsonFilename);
            // merge commands specified in command-line.json and default (re)build settings
            // Ensure both build commands are included and preserve any other commands specified
            if (commandLineJson && commandLineJson.commands) {
                for (let i = 0; i < commandLineJson.commands.length; i++) {
                    const command = commandLineJson.commands[i];
                    // Determine if we have a set of default parameters
                    let commandDefaultDefinition = {};
                    switch (command.commandKind) {
                        case RushConstants_1.RushConstants.bulkCommandKind: {
                            switch (command.name) {
                                case RushConstants_1.RushConstants.buildCommandName: {
                                    commandDefaultDefinition = DEFAULT_BUILD_COMMAND_JSON;
                                    break;
                                }
                                case RushConstants_1.RushConstants.rebuildCommandName: {
                                    commandDefaultDefinition = DEFAULT_REBUILD_COMMAND_JSON;
                                    break;
                                }
                            }
                            break;
                        }
                    }
                    // Merge the default parameters into the repo-specified parameters
                    commandLineJson.commands[i] = Object.assign(Object.assign({}, commandDefaultDefinition), command);
                }
                CommandLineConfiguration._jsonSchema.validateObject(commandLineJson, jsonFilename);
            }
        }
        return new CommandLineConfiguration(commandLineJson);
    }
    get additionalPathFolders() {
        return this._additionalPathFolders;
    }
    prependAdditionalPathFolder(pathFolder) {
        this._additionalPathFolders.unshift(pathFolder);
    }
    /**
     * This function replaces colons (":") with underscores ("_").
     *
     * ts-command-line restricts command names to lowercase letters, numbers, underscores, and colons.
     * Replacing colons with underscores produces a filesystem-safe name.
     */
    _normalizeNameForLogFilenameIdentifiers(name) {
        return name.replace(/:/g, '_'); // Replace colons with underscores to be filesystem-safe
    }
    _translateBulkCommandToPhasedCommand(command) {
        const phaseName = command.name;
        const phaseForBulkCommand = {
            name: phaseName,
            isSynthetic: true,
            dependencies: {
                upstream: command.ignoreDependencyOrder ? undefined : [phaseName]
            },
            ignoreMissingScript: command.ignoreMissingScript,
            allowWarningsOnSuccess: command.allowWarningsInSuccessfulBuild,
            logFilenameIdentifier: this._normalizeNameForLogFilenameIdentifiers(command.name),
            associatedParameters: new Set()
        };
        this.phases.set(phaseName, phaseForBulkCommand);
        this._syntheticPhasesNamesByTranslatedBulkCommandName.set(command.name, phaseName);
        const translatedCommand = Object.assign(Object.assign({}, command), { commandKind: 'phased', disableBuildCache: true, isSynthetic: true, associatedParameters: new Set(), phases: [phaseName] });
        return translatedCommand;
    }
}
exports.CommandLineConfiguration = CommandLineConfiguration;
CommandLineConfiguration._jsonSchema = node_core_library_1.JsonSchema.fromFile(path.join(__dirname, '../schemas/command-line.schema.json'));
//# sourceMappingURL=CommandLineConfiguration.js.map