{"version":3,"file":"RushProjectConfiguration.js","sourceRoot":"","sources":["../../src/api/RushProjectConfiguration.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport { AlreadyReportedError, ITerminal, Path } from '@rushstack/node-core-library';\nimport { ConfigurationFile, InheritanceType } from '@rushstack/heft-config-file';\nimport { RigConfig } from '@rushstack/rig-package';\n\nimport { RushConfigurationProject } from './RushConfigurationProject';\nimport { RushConstants } from '../logic/RushConstants';\nimport { CommandLineConfiguration } from './CommandLineConfiguration';\nimport { OverlappingPathAnalyzer } from '../utilities/OverlappingPathAnalyzer';\n\n/**\n * Describes the file structure for the \"<project root>/config/rush-project.json\" config file.\n */\nexport interface IRushProjectJson {\n  /**\n   * A list of folder names under the project root that should be cached.\n   *\n   * These folders should not be tracked by git.\n   */\n  projectOutputFolderNames?: string[];\n\n  /**\n   * Options for individual phases.\n   */\n  phaseOptions?: IRushProjectJsonPhaseOptionsJson[];\n\n  /**\n   * The incremental analyzer can skip Rush commands for projects whose input files have\n   * not changed since the last build. Normally, every Git-tracked file under the project\n   * folder is assumed to be an input. Set incrementalBuildIgnoredGlobs to ignore specific\n   * files, specified as globs relative to the project folder. The list of file globs will\n   * be interpreted the same way your .gitignore file is.\n   */\n  incrementalBuildIgnoredGlobs?: string[];\n\n  /**\n   * Additional project-specific options related to build caching.\n   */\n  buildCacheOptions?: IBuildCacheOptionsJson;\n}\n\nexport interface IRushProjectJsonPhaseOptionsJson {\n  /**\n   * The name of the phase. This is the name that appears in command-line.json.\n   */\n  phaseName: string;\n\n  /**\n   * A list of folder names under the project root that should be cached.\n   *\n   * These folders should not be tracked by git.\n   */\n  projectOutputFolderNames?: string[];\n}\n\nexport interface IBuildCacheOptionsJson extends IBuildCacheOptionsBase {\n  /**\n   * Allows for fine-grained control of cache for individual commands.\n   */\n  optionsForCommands?: ICacheOptionsForCommand[];\n}\n\nexport interface IBuildCacheOptionsBase {\n  /**\n   * Disable caching for this project. The project will never be restored from cache.\n   * This may be useful if this project affects state outside of its folder.\n   *\n   * This option is only used when the cloud build cache is enabled for the repo. You can set\n   * disableBuildCache=true to disable caching for a specific project. This is a useful workaround\n   * if that project's build scripts violate the assumptions of the cache, for example by writing\n   * files outside the project folder. Where possible, a better solution is to improve the build scripts\n   * to be compatible with caching.\n   */\n  disableBuildCache?: boolean;\n}\n\nexport interface IBuildCacheOptions extends IBuildCacheOptionsBase {\n  /**\n   * Allows for fine-grained control of cache for individual commands.\n   */\n  optionsForCommandsByName: Map<string, ICacheOptionsForCommand>;\n}\n\nexport interface ICacheOptionsForCommand {\n  /**\n   * The command name.\n   */\n  name: string;\n\n  /**\n   * Disable caching for this command.\n   * This may be useful if this command for this project affects state outside of this project folder.\n   *\n   * This option is only used when the cloud build cache is enabled for the repo. You can set\n   * disableBuildCache=true to disable caching for a command in a specific project. This is a useful workaround\n   * if that project's build scripts violate the assumptions of the cache, for example by writing\n   * files outside the project folder. Where possible, a better solution is to improve the build scripts\n   * to be compatible with caching.\n   */\n  disableBuildCache?: boolean;\n}\n\nexport const RUSH_PROJECT_CONFIGURATION_FILE: ConfigurationFile<IRushProjectJson> =\n  new ConfigurationFile<IRushProjectJson>({\n    projectRelativeFilePath: `config/${RushConstants.rushProjectConfigFilename}`,\n    jsonSchemaPath: path.resolve(__dirname, '..', 'schemas', 'rush-project.schema.json'),\n    propertyInheritance: {\n      projectOutputFolderNames: {\n        inheritanceType: InheritanceType.append\n      },\n      phaseOptions: {\n        inheritanceType: InheritanceType.custom,\n        inheritanceFunction: (\n          child: IRushProjectJsonPhaseOptionsJson[] | undefined,\n          parent: IRushProjectJsonPhaseOptionsJson[] | undefined\n        ) => {\n          if (!child) {\n            return parent;\n          } else if (!parent) {\n            return child;\n          } else {\n            // Merge the projectOutputFolderNames arrays\n\n            const resultPhaseOptionsByPhaseName: Map<string, IRushProjectJsonPhaseOptionsJson> = new Map();\n            for (const parentPhaseOptions of parent) {\n              resultPhaseOptionsByPhaseName.set(parentPhaseOptions.phaseName, parentPhaseOptions);\n            }\n\n            const childEncounteredPhaseNames: Set<string> = new Set();\n            for (const childPhaseOptions of child) {\n              const phaseName: string = childPhaseOptions.phaseName;\n              if (childEncounteredPhaseNames.has(phaseName)) {\n                // If the phase options already exist, but didn't come from the parent, then\n                // it shows up multiple times in the child.\n                const childSourceFilePath: string =\n                  RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(child)!;\n                throw new Error(\n                  `The phase \"${phaseName}\" occurs multiple times in the \"phaseOptions\" array ` +\n                    `in \"${childSourceFilePath}\".`\n                );\n              }\n\n              childEncounteredPhaseNames.add(phaseName);\n\n              let mergedPhaseOptions: IRushProjectJsonPhaseOptionsJson | undefined =\n                resultPhaseOptionsByPhaseName.get(phaseName);\n              if (mergedPhaseOptions) {\n                // The parent phase options object already exists, so append to the projectOutputFolderNames\n                const projectOutputFolderNames: string[] | undefined =\n                  mergedPhaseOptions.projectOutputFolderNames && childPhaseOptions.projectOutputFolderNames\n                    ? [\n                        ...mergedPhaseOptions.projectOutputFolderNames,\n                        ...childPhaseOptions.projectOutputFolderNames\n                      ]\n                    : mergedPhaseOptions.projectOutputFolderNames ||\n                      childPhaseOptions.projectOutputFolderNames;\n\n                mergedPhaseOptions = {\n                  ...mergedPhaseOptions,\n                  ...childPhaseOptions,\n                  projectOutputFolderNames\n                };\n                resultPhaseOptionsByPhaseName.set(phaseName, mergedPhaseOptions);\n              } else {\n                resultPhaseOptionsByPhaseName.set(phaseName, childPhaseOptions);\n              }\n            }\n\n            return Array.from(resultPhaseOptionsByPhaseName.values());\n          }\n        }\n      },\n      incrementalBuildIgnoredGlobs: {\n        inheritanceType: InheritanceType.replace\n      },\n      buildCacheOptions: {\n        inheritanceType: InheritanceType.custom,\n        inheritanceFunction: (\n          current: IBuildCacheOptionsJson | undefined,\n          parent: IBuildCacheOptionsJson | undefined\n        ): IBuildCacheOptionsJson | undefined => {\n          if (!current) {\n            return parent;\n          } else if (!parent) {\n            return current;\n          } else {\n            return {\n              ...parent,\n              ...current,\n              optionsForCommands: [\n                ...(parent.optionsForCommands || []),\n                ...(current.optionsForCommands || [])\n              ]\n            };\n          }\n        }\n      }\n    }\n  });\n\n/**\n * Use this class to load the \"config/rush-project.json\" config file.\n *\n * This file provides project-specific configuration options.\n * @public\n */\nexport class RushProjectConfiguration {\n  private static readonly _configCache: Map<RushConfigurationProject, RushProjectConfiguration | false> =\n    new Map();\n\n  public readonly project: RushConfigurationProject;\n\n  /**\n   * A list of folder names under the project root that should be cached for each phase.\n   *\n   * These folders should not be tracked by git.\n   *\n   * @remarks\n   * The `projectOutputFolderNames` property is populated in a \"build\" entry\n   */\n  public readonly projectOutputFolderNamesForPhases: ReadonlyMap<string, ReadonlyArray<string>>;\n\n  /**\n   * The incremental analyzer can skip Rush commands for projects whose input files have\n   * not changed since the last build. Normally, every Git-tracked file under the project\n   * folder is assumed to be an input. Set incrementalBuildIgnoredGlobs to ignore specific\n   * files, specified as globs relative to the project folder. The list of file globs will\n   * be interpreted the same way your .gitignore file is.\n   */\n  public readonly incrementalBuildIgnoredGlobs?: ReadonlyArray<string>;\n\n  /**\n   * Project-specific cache options.\n   */\n  public readonly cacheOptions: IBuildCacheOptions;\n\n  private constructor(\n    project: RushConfigurationProject,\n    rushProjectJson: IRushProjectJson,\n    projectOutputFolderNamesForPhases: ReadonlyMap<string, ReadonlyArray<string>>\n  ) {\n    this.project = project;\n\n    this.projectOutputFolderNamesForPhases = projectOutputFolderNamesForPhases;\n\n    this.incrementalBuildIgnoredGlobs = rushProjectJson.incrementalBuildIgnoredGlobs;\n\n    const optionsForCommandsByName: Map<string, ICacheOptionsForCommand> = new Map<\n      string,\n      ICacheOptionsForCommand\n    >();\n    if (rushProjectJson.buildCacheOptions?.optionsForCommands) {\n      for (const cacheOptionsForCommand of rushProjectJson.buildCacheOptions.optionsForCommands) {\n        optionsForCommandsByName.set(cacheOptionsForCommand.name, cacheOptionsForCommand);\n      }\n    }\n    this.cacheOptions = {\n      disableBuildCache: rushProjectJson.buildCacheOptions?.disableBuildCache,\n      optionsForCommandsByName\n    };\n  }\n\n  /**\n   * Loads the rush-project.json data for the specified project.\n   */\n  public static async tryLoadForProjectAsync(\n    project: RushConfigurationProject,\n    repoCommandLineConfiguration: CommandLineConfiguration,\n    terminal: ITerminal\n  ): Promise<RushProjectConfiguration | undefined> {\n    // false is a signal that the project config does not exist\n    const cacheEntry: RushProjectConfiguration | false | undefined =\n      RushProjectConfiguration._configCache.get(project);\n    if (cacheEntry !== undefined) {\n      return cacheEntry || undefined;\n    }\n\n    const rushProjectJson: IRushProjectJson | undefined = await this._tryLoadJsonForProjectAsync(\n      project,\n      terminal\n    );\n\n    if (rushProjectJson) {\n      const result: RushProjectConfiguration = RushProjectConfiguration._getRushProjectConfiguration(\n        project,\n        rushProjectJson,\n        repoCommandLineConfiguration,\n        terminal\n      );\n      RushProjectConfiguration._configCache.set(project, result);\n      return result;\n    } else {\n      RushProjectConfiguration._configCache.set(project, false);\n      return undefined;\n    }\n  }\n\n  /**\n   * Load only the `incrementalBuildIgnoredGlobs` property from the rush-project.json file, skipping\n   * validation of other parts of the config file.\n   *\n   * @remarks\n   * This function exists to allow the ProjectChangeAnalyzer to load just the ignore globs without\n   * having to validate the rest of the `rush-project.json` file against the repo's command-line configuration.\n   */\n  public static async tryLoadIgnoreGlobsForProjectAsync(\n    project: RushConfigurationProject,\n    terminal: ITerminal\n  ): Promise<ReadonlyArray<string> | undefined> {\n    const rushProjectJson: IRushProjectJson | undefined = await this._tryLoadJsonForProjectAsync(\n      project,\n      terminal\n    );\n\n    return rushProjectJson?.incrementalBuildIgnoredGlobs;\n  }\n\n  private static async _tryLoadJsonForProjectAsync(\n    project: RushConfigurationProject,\n    terminal: ITerminal\n  ): Promise<IRushProjectJson | undefined> {\n    const rigConfig: RigConfig = await RigConfig.loadForProjectFolderAsync({\n      projectFolderPath: project.projectFolder\n    });\n\n    const rushProjectJson: IRushProjectJson | undefined =\n      await RUSH_PROJECT_CONFIGURATION_FILE.tryLoadConfigurationFileForProjectAsync(\n        terminal,\n        project.projectFolder,\n        rigConfig\n      );\n\n    return rushProjectJson;\n  }\n\n  private static _getRushProjectConfiguration(\n    project: RushConfigurationProject,\n    rushProjectJson: IRushProjectJson,\n    repoCommandLineConfiguration: CommandLineConfiguration,\n    terminal: ITerminal\n  ): RushProjectConfiguration {\n    if (rushProjectJson.projectOutputFolderNames) {\n      const overlappingPathAnalyzer: OverlappingPathAnalyzer<boolean> =\n        new OverlappingPathAnalyzer<boolean>();\n\n      const invalidFolderNames: string[] = [];\n      for (const projectOutputFolder of rushProjectJson.projectOutputFolderNames) {\n        if (projectOutputFolder.match(/[\\\\]/)) {\n          invalidFolderNames.push(projectOutputFolder);\n        }\n\n        const overlaps: boolean = !!overlappingPathAnalyzer.addPathAndGetFirstEncounteredLabels(\n          projectOutputFolder,\n          true\n        );\n        if (overlaps) {\n          terminal.writeErrorLine(\n            `The project output folder name \"${projectOutputFolder}\" is invalid because it overlaps with another folder name.`\n          );\n          throw new AlreadyReportedError();\n        }\n      }\n\n      if (invalidFolderNames.length > 0) {\n        terminal.writeErrorLine(\n          `Invalid project configuration for project \"${project.packageName}\". Entries in ` +\n            '\"projectOutputFolderNames\" must not contain backslashes and the following entries do: ' +\n            invalidFolderNames.join(', ')\n        );\n      }\n    }\n\n    const duplicateCommandNames: Set<string> = new Set<string>();\n    const invalidCommandNames: string[] = [];\n    if (rushProjectJson.buildCacheOptions?.optionsForCommands) {\n      const commandNames: Set<string> = new Set<string>();\n      for (const [commandName, command] of repoCommandLineConfiguration.commands) {\n        if (command.commandKind === RushConstants.phasedCommandKind) {\n          commandNames.add(commandName);\n        }\n      }\n\n      const alreadyEncounteredCommandNames: Set<string> = new Set<string>();\n      for (const cacheOptionsForCommand of rushProjectJson.buildCacheOptions.optionsForCommands) {\n        const commandName: string = cacheOptionsForCommand.name;\n        if (!commandNames.has(commandName)) {\n          invalidCommandNames.push(commandName);\n        } else if (alreadyEncounteredCommandNames.has(commandName)) {\n          duplicateCommandNames.add(commandName);\n        } else {\n          alreadyEncounteredCommandNames.add(commandName);\n        }\n      }\n    }\n\n    if (invalidCommandNames.length > 0) {\n      terminal.writeErrorLine(\n        `Invalid project configuration fpr project \"${project.packageName}\". The following ` +\n          'command names in cacheOptions.optionsForCommands are not specified in this repo: ' +\n          invalidCommandNames.join(', ')\n      );\n    }\n\n    if (duplicateCommandNames.size > 0) {\n      terminal.writeErrorLine(\n        `Invalid project configuration fpr project \"${project.packageName}\". The following ` +\n          'command names in cacheOptions.optionsForCommands are specified more than once: ' +\n          Array.from(duplicateCommandNames).join(', ')\n      );\n    }\n\n    const projectOutputFolderNamesForPhases: Map<string, string[]> = new Map<string, string[]>();\n    if (rushProjectJson.projectOutputFolderNames) {\n      projectOutputFolderNamesForPhases.set(\n        RushConstants.buildCommandName,\n        rushProjectJson.projectOutputFolderNames\n      );\n    }\n\n    if (rushProjectJson.phaseOptions) {\n      const overlappingPathAnalyzer: OverlappingPathAnalyzer<string> = new OverlappingPathAnalyzer<string>();\n      const phaseOptionsByPhase: Map<string, IRushProjectJsonPhaseOptionsJson> = new Map<\n        string,\n        IRushProjectJsonPhaseOptionsJson\n      >();\n      for (const phaseOptions of rushProjectJson.phaseOptions) {\n        const phaseName: string = phaseOptions.phaseName;\n        const existingPhaseOptions: IRushProjectJsonPhaseOptionsJson | undefined =\n          phaseOptionsByPhase.get(phaseName);\n        if (existingPhaseOptions) {\n          const existingPhaseOptionsJsonPath: string | undefined =\n            RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(existingPhaseOptions);\n          const phaseOptionsJsonPath: string | undefined =\n            RUSH_PROJECT_CONFIGURATION_FILE.getObjectSourceFilePath(phaseOptions);\n          let errorMessage: string =\n            `The phase \"${phaseName}\" appears multiple times in the \"${project.packageName}\" project's ` +\n            `${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath} file's ` +\n            'phaseOptions property.';\n          if (existingPhaseOptionsJsonPath && phaseOptionsJsonPath) {\n            if (existingPhaseOptionsJsonPath !== phaseOptionsJsonPath) {\n              errorMessage +=\n                ` It first appears in \"${existingPhaseOptionsJsonPath}\" and again ` +\n                `in \"${phaseOptionsJsonPath}\".`;\n            } else if (\n              !Path.convertToSlashes(existingPhaseOptionsJsonPath).startsWith(\n                Path.convertToSlashes(project.projectFolder)\n              )\n            ) {\n              errorMessage += ` It appears multiple times in \"${phaseOptionsJsonPath}\".`;\n            }\n          }\n\n          terminal.writeErrorLine(errorMessage);\n        } else if (!repoCommandLineConfiguration.phases.has(phaseName)) {\n          terminal.writeErrorLine(\n            `Invalid \"${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath}\"` +\n              ` for project \"${project.packageName}\". Phase \"${phaseName}\" is not defined in the repo's ${RushConstants.commandLineFilename}.`\n          );\n        } else {\n          phaseOptionsByPhase.set(phaseOptions.phaseName, phaseOptions);\n          if (phaseOptions.projectOutputFolderNames) {\n            projectOutputFolderNamesForPhases.set(\n              phaseOptions.phaseName,\n              phaseOptions.projectOutputFolderNames\n            );\n          }\n        }\n\n        if (phaseOptions.projectOutputFolderNames) {\n          for (const projectOutputFolderName of phaseOptions.projectOutputFolderNames) {\n            const overlappingPhaseNames: string[] | undefined =\n              overlappingPathAnalyzer.addPathAndGetFirstEncounteredLabels(projectOutputFolderName, phaseName);\n            if (overlappingPhaseNames) {\n              const overlapsWithOwnPhase: boolean = overlappingPhaseNames?.includes(phaseName);\n              if (overlapsWithOwnPhase) {\n                if (overlappingPhaseNames.length === 1) {\n                  terminal.writeErrorLine(\n                    `Invalid \"${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath}\" ` +\n                      `for project \"${project.packageName}\". The project output folder name \"${projectOutputFolderName}\" in ` +\n                      `phase ${phaseName} overlaps with another folder name in the same phase.`\n                  );\n                } else {\n                  const otherPhaseNames: string[] = overlappingPhaseNames.filter(\n                    (overlappingPhaseName) => overlappingPhaseName !== phaseName\n                  );\n                  terminal.writeErrorLine(\n                    `Invalid \"${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath}\" ` +\n                      `for project \"${project.packageName}\". The project output folder name \"${projectOutputFolderName}\" in ` +\n                      `phase ${phaseName} overlaps with other folder names in the same phase and with ` +\n                      `folder names in the following other phases: ${otherPhaseNames.join(', ')}.`\n                  );\n                }\n              } else {\n                terminal.writeErrorLine(\n                  `Invalid \"${RUSH_PROJECT_CONFIGURATION_FILE.projectRelativeFilePath}\" ` +\n                    `for project \"${project.packageName}\". The project output folder name \"${projectOutputFolderName}\" in ` +\n                    `phase ${phaseName} overlaps with other folder name(s) in the following other phases: ` +\n                    `${overlappingPhaseNames.join(', ')}.`\n                );\n              }\n\n              throw new AlreadyReportedError();\n            }\n          }\n        }\n      }\n    }\n\n    return new RushProjectConfiguration(project, rushProjectJson, projectOutputFolderNamesForPhases);\n  }\n}\n"]}