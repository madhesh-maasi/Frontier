{"version":3,"file":"CommandLineConfiguration.js","sourceRoot":"","sources":["../../src/api/CommandLineConfiguration.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport { JsonFile, JsonSchema, FileSystem } from '@rushstack/node-core-library';\n\nimport { RushConstants } from '../logic/RushConstants';\nimport type {\n  CommandJson,\n  ICommandLineJson,\n  IPhaseJson,\n  IPhasedCommandJson,\n  IBulkCommandJson,\n  IGlobalCommandJson,\n  IFlagParameterJson,\n  IChoiceParameterJson,\n  IStringParameterJson\n} from './CommandLineJson';\n\nexport interface IShellCommandTokenContext {\n  packageFolder: string;\n}\n\nexport interface IPhase extends IPhaseJson {\n  /**\n   * If set to \"true,\" this this phase was generated from a bulk command, and\n   * was not explicitly defined in the command-line.json file.\n   */\n  isSynthetic: boolean;\n\n  /**\n   * This property is used in the name of the filename for the logs generated by this\n   * phase. This is a filesystem-safe version of the phase name. For example,\n   * a phase with name \"_phase:compile\" has a `logFilenameIdentifier` of \"_phase_compile\".\n   */\n  logFilenameIdentifier: string;\n\n  associatedParameters: Set<Parameter>;\n}\n\nexport interface ICommandWithParameters {\n  associatedParameters: Set<Parameter>;\n}\nexport interface IPhasedCommand extends IPhasedCommandJson, ICommandWithParameters {\n  /**\n   * If set to \"true,\" this this phased command was generated from a bulk command, and\n   * was not explicitly defined in the command-line.json file.\n   */\n  isSynthetic: boolean;\n  watchForChanges?: boolean;\n  disableBuildCache?: boolean;\n}\n\nexport interface IGlobalCommand extends IGlobalCommandJson, ICommandWithParameters {}\n\nexport type Command = IGlobalCommand | IPhasedCommand;\n\nexport type Parameter = IFlagParameterJson | IChoiceParameterJson | IStringParameterJson;\n\nconst DEFAULT_BUILD_COMMAND_JSON: IBulkCommandJson = {\n  commandKind: RushConstants.bulkCommandKind,\n  name: RushConstants.buildCommandName,\n  summary: \"Build all projects that haven't been built, or have changed since they were last built.\",\n  description:\n    'This command is similar to \"rush rebuild\", except that \"rush build\" performs' +\n    ' an incremental build. In other words, it only builds projects whose source files have changed' +\n    ' since the last successful build. The analysis requires a Git working tree, and only considers' +\n    ' source files that are tracked by Git and whose path is under the project folder. (For more details' +\n    ' about this algorithm, see the documentation for the \"package-deps-hash\" NPM package.) The incremental' +\n    ' build state is tracked in a per-project folder called \".rush/temp\" which should NOT be added to Git. The' +\n    ' build command is tracked by the \"arguments\" field in the \"package-deps_build.json\" file contained' +\n    ' therein; a full rebuild is forced whenever the command has changed (e.g. \"--production\" or not).',\n  enableParallelism: true,\n  ignoreMissingScript: false,\n  ignoreDependencyOrder: false,\n  incremental: true,\n  allowWarningsInSuccessfulBuild: false,\n  safeForSimultaneousRushProcesses: false\n};\n\nconst DEFAULT_REBUILD_COMMAND_JSON: IBulkCommandJson = {\n  commandKind: RushConstants.bulkCommandKind,\n  name: RushConstants.rebuildCommandName,\n  summary: 'Clean and rebuild the entire set of projects.',\n  description:\n    'This command assumes that the package.json file for each project contains' +\n    ' a \"scripts\" entry for \"npm run build\" that performs a full clean build.' +\n    ' Rush invokes this script to build each project that is registered in rush.json.' +\n    ' Projects are built in parallel where possible, but always respecting the dependency' +\n    ' graph for locally linked projects.  The number of simultaneous processes will be' +\n    ' based on the number of machine cores unless overridden by the --parallelism flag.' +\n    ' (For an incremental build, see \"rush build\" instead of \"rush rebuild\".)',\n  enableParallelism: true,\n  ignoreMissingScript: false,\n  ignoreDependencyOrder: false,\n  incremental: false,\n  allowWarningsInSuccessfulBuild: false,\n  safeForSimultaneousRushProcesses: false\n};\n\n/**\n * Custom Commands and Options for the Rush Command Line\n */\nexport class CommandLineConfiguration {\n  private static _jsonSchema: JsonSchema = JsonSchema.fromFile(\n    path.join(__dirname, '../schemas/command-line.schema.json')\n  );\n\n  public readonly commands: Map<string, Command> = new Map();\n  public readonly phases: Map<string, IPhase> = new Map();\n  public readonly parameters: Parameter[] = [];\n\n  /**\n   * shellCommand from plugin custom command line configuration needs to be expanded with tokens\n   */\n  public shellCommandTokenContext: IShellCommandTokenContext | undefined;\n\n  /**\n   * These path will be prepended to the PATH environment variable\n   */\n  private readonly _additionalPathFolders: string[] = [];\n\n  /**\n   * A map of bulk command names to their corresponding synthetic phase identifiers\n   */\n  private readonly _syntheticPhasesNamesByTranslatedBulkCommandName: Map<string, string> = new Map();\n\n  /**\n   * Use CommandLineConfiguration.loadFromFile()\n   *\n   * @internal\n   */\n  public constructor(commandLineJson: ICommandLineJson | undefined) {\n    if (commandLineJson?.phases) {\n      const phaseNameRegexp: RegExp = new RegExp(\n        `^${RushConstants.phaseNamePrefix}[a-z][a-z0-9]*([-][a-z0-9]+)*$`\n      );\n      for (const phase of commandLineJson.phases) {\n        if (this.phases.has(phase.name)) {\n          throw new Error(\n            `In ${RushConstants.commandLineFilename}, the phase \"${phase.name}\" is specified ` +\n              'more than once.'\n          );\n        }\n\n        if (!phase.name.match(phaseNameRegexp)) {\n          throw new Error(\n            `In ${RushConstants.commandLineFilename}, the phase \"${phase.name}\"'s name ` +\n              'is not a valid phase name. Phase names must begin with the ' +\n              `required prefix \"${RushConstants.phaseNamePrefix}\" followed by a name containing ` +\n              'lowercase letters, numbers, or hyphens. The name must start with a letter and ' +\n              'must not end with a hyphen.'\n          );\n        }\n\n        this.phases.set(phase.name, {\n          ...phase,\n          isSynthetic: false,\n          logFilenameIdentifier: this._normalizeNameForLogFilenameIdentifiers(phase.name),\n          associatedParameters: new Set()\n        });\n      }\n    }\n\n    for (const phase of this.phases.values()) {\n      if (phase.dependencies?.self) {\n        for (const dependencyName of phase.dependencies.self) {\n          const dependency: IPhase | undefined = this.phases.get(dependencyName);\n          if (!dependency) {\n            throw new Error(\n              `In ${RushConstants.commandLineFilename}, in the phase \"${phase.name}\", the self ` +\n                `dependency phase \"${dependencyName}\" does not exist.`\n            );\n          }\n        }\n      }\n\n      if (phase.dependencies?.upstream) {\n        for (const dependency of phase.dependencies.upstream) {\n          if (!this.phases.has(dependency)) {\n            throw new Error(\n              `In ${RushConstants.commandLineFilename}, in the phase \"${phase.name}\", ` +\n                `the upstream dependency phase \"${dependency}\" does not exist.`\n            );\n          }\n        }\n      }\n\n      this._checkForPhaseSelfCycles(phase);\n    }\n\n    let buildCommandPhases: string[] | undefined;\n    if (commandLineJson?.commands) {\n      for (const command of commandLineJson.commands) {\n        if (this.commands.has(command.name)) {\n          throw new Error(\n            `In ${RushConstants.commandLineFilename}, the command \"${command.name}\" is specified ` +\n              'more than once.'\n          );\n        }\n\n        let normalizedCommand: Command;\n        switch (command.commandKind) {\n          case RushConstants.phasedCommandKind: {\n            normalizedCommand = {\n              ...command,\n              isSynthetic: false,\n              associatedParameters: new Set<Parameter>()\n            };\n\n            for (const phaseName of normalizedCommand.phases) {\n              if (!this.phases.has(phaseName)) {\n                throw new Error(\n                  `In ${RushConstants.commandLineFilename}, in the \"phases\" property of the ` +\n                    `\"${normalizedCommand.name}\" command, the phase \"${phaseName}\" does not exist.`\n                );\n              }\n            }\n\n            if (normalizedCommand.skipPhasesForCommand) {\n              for (const phaseName of normalizedCommand.skipPhasesForCommand) {\n                if (!this.phases.has(phaseName)) {\n                  throw new Error(\n                    `In ${RushConstants.commandLineFilename}, in the \"skipPhasesForCommand\" property of the ` +\n                      `\"${normalizedCommand.name}\" command, the phase ` +\n                      `\"${phaseName}\" does not exist.`\n                  );\n                }\n              }\n            }\n\n            break;\n          }\n\n          case RushConstants.globalCommandKind: {\n            normalizedCommand = {\n              ...command,\n              associatedParameters: new Set<Parameter>()\n            };\n            break;\n          }\n\n          case RushConstants.bulkCommandKind: {\n            // Translate the bulk command into a phased command\n            normalizedCommand = this._translateBulkCommandToPhasedCommand(command);\n            break;\n          }\n        }\n\n        if (\n          normalizedCommand.name === RushConstants.buildCommandName ||\n          normalizedCommand.name === RushConstants.rebuildCommandName\n        ) {\n          if (normalizedCommand.commandKind === RushConstants.globalCommandKind) {\n            throw new Error(\n              `${RushConstants.commandLineFilename} defines a command \"${normalizedCommand.name}\" using ` +\n                `the command kind \"${RushConstants.globalCommandKind}\". This command can only be designated as a command ` +\n                `kind \"${RushConstants.bulkCommandKind}\" or \"${RushConstants.phasedCommandKind}\".`\n            );\n          } else if (command.safeForSimultaneousRushProcesses) {\n            throw new Error(\n              `${RushConstants.commandLineFilename} defines a command \"${normalizedCommand.name}\" using ` +\n                `\"safeForSimultaneousRushProcesses=true\". This configuration is not supported for \"${normalizedCommand.name}\".`\n            );\n          } else if (normalizedCommand.name === RushConstants.buildCommandName) {\n            // Record the build command phases in case we need to construct a synthetic \"rebuild\" command\n            buildCommandPhases = normalizedCommand.phases;\n          }\n        }\n\n        this.commands.set(normalizedCommand.name, normalizedCommand);\n      }\n    }\n\n    let buildCommand: Command | undefined = this.commands.get(RushConstants.buildCommandName);\n    if (!buildCommand) {\n      // If the build command was not specified in the config file, add the default build command\n      buildCommand = this._translateBulkCommandToPhasedCommand(DEFAULT_BUILD_COMMAND_JSON);\n      buildCommand.disableBuildCache = DEFAULT_BUILD_COMMAND_JSON.disableBuildCache;\n      buildCommandPhases = buildCommand.phases;\n      this.commands.set(buildCommand.name, buildCommand);\n    }\n\n    if (!this.commands.has(RushConstants.rebuildCommandName)) {\n      // If a rebuild command was not specified in the config file, add the default rebuild command\n      if (!buildCommandPhases) {\n        throw new Error(`Phases for the \"${RushConstants.buildCommandName}\" were not found.`);\n      }\n\n      const rebuildCommand: IPhasedCommand = {\n        ...DEFAULT_REBUILD_COMMAND_JSON,\n        commandKind: RushConstants.phasedCommandKind,\n        isSynthetic: true,\n        phases: buildCommandPhases,\n        disableBuildCache: DEFAULT_REBUILD_COMMAND_JSON.disableBuildCache,\n        associatedParameters: buildCommand.associatedParameters // rebuild should share build's parameters in this case\n      };\n      this.commands.set(rebuildCommand.name, rebuildCommand);\n    }\n\n    if (commandLineJson?.parameters) {\n      for (const parameter of commandLineJson.parameters) {\n        const normalizedParameter: Parameter = {\n          ...parameter,\n          associatedPhases: parameter.associatedPhases ? [...parameter.associatedPhases] : [],\n          associatedCommands: parameter.associatedCommands ? [...parameter.associatedCommands] : []\n        };\n\n        this.parameters.push(normalizedParameter);\n\n        let parameterHasAssociatedPhases: boolean = false;\n\n        // Do some basic validation\n        switch (normalizedParameter.parameterKind) {\n          case 'flag': {\n            const addPhasesToCommandSet: Set<string> = new Set<string>();\n\n            if (normalizedParameter.addPhasesToCommand) {\n              for (const phaseName of normalizedParameter.addPhasesToCommand) {\n                addPhasesToCommandSet.add(phaseName);\n                const phase: IPhase | undefined = this.phases.get(phaseName);\n                if (!phase || phase.isSynthetic) {\n                  throw new Error(\n                    `${RushConstants.commandLineFilename} defines a parameter \"${normalizedParameter.longName}\" ` +\n                      `that lists phase \"${phaseName}\" in its \"addPhasesToCommand\" ` +\n                      'property that does not exist.'\n                  );\n                }\n\n                parameterHasAssociatedPhases = true;\n              }\n            }\n\n            if (normalizedParameter.skipPhasesForCommand) {\n              for (const phaseName of normalizedParameter.skipPhasesForCommand) {\n                const phase: IPhase | undefined = this.phases.get(phaseName);\n                if (!phase || phase.isSynthetic) {\n                  throw new Error(\n                    `${RushConstants.commandLineFilename} defines a parameter \"${normalizedParameter.longName}\" ` +\n                      `that lists phase \"${phaseName}\" in its skipPhasesForCommand\" ` +\n                      'property that does not exist.'\n                  );\n                } else if (addPhasesToCommandSet.has(phaseName)) {\n                  throw new Error(\n                    `${RushConstants.commandLineFilename} defines a parameter \"${normalizedParameter.longName}\" ` +\n                      `that lists phase \"${phaseName}\" in both its \"addPhasesToCommand\" ` +\n                      'and \"skipPhasesForCommand\" properties.'\n                  );\n                }\n\n                parameterHasAssociatedPhases = true;\n              }\n            }\n\n            break;\n          }\n\n          case 'choice': {\n            const alternativeNames: string[] = normalizedParameter.alternatives.map((x) => x.name);\n\n            if (\n              normalizedParameter.defaultValue &&\n              alternativeNames.indexOf(normalizedParameter.defaultValue) < 0\n            ) {\n              throw new Error(\n                `In ${RushConstants.commandLineFilename}, the parameter \"${normalizedParameter.longName}\",` +\n                  ` specifies a default value \"${normalizedParameter.defaultValue}\"` +\n                  ` which is not one of the defined alternatives: \"${alternativeNames.toString()}\"`\n              );\n            }\n\n            break;\n          }\n        }\n\n        let parameterHasAssociatedCommands: boolean = false;\n        let parameterIsOnlyAssociatedWithPhasedCommands: boolean = true;\n        if (normalizedParameter.associatedCommands) {\n          for (const associatedCommandName of normalizedParameter.associatedCommands) {\n            const syntheticPhaseName: string | undefined =\n              this._syntheticPhasesNamesByTranslatedBulkCommandName.get(associatedCommandName);\n            if (syntheticPhaseName) {\n              // If this parameter was associated with a bulk command, include the association\n              // with the synthetic phase\n              normalizedParameter.associatedPhases!.push(syntheticPhaseName);\n            }\n\n            const associatedCommand: Command | undefined = this.commands.get(associatedCommandName);\n            if (!associatedCommand) {\n              throw new Error(\n                `${RushConstants.commandLineFilename} defines a parameter \"${normalizedParameter.longName}\" ` +\n                  `that is associated with a command \"${associatedCommandName}\" that does not exist or does ` +\n                  'not support custom parameters.'\n              );\n            } else {\n              associatedCommand.associatedParameters.add(normalizedParameter);\n              parameterHasAssociatedCommands = true;\n\n              if (associatedCommand.commandKind !== RushConstants.phasedCommandKind) {\n                parameterIsOnlyAssociatedWithPhasedCommands = false;\n              }\n            }\n          }\n        }\n\n        if (normalizedParameter.associatedPhases) {\n          for (const associatedPhaseName of normalizedParameter.associatedPhases) {\n            const associatedPhase: IPhase | undefined = this.phases.get(associatedPhaseName);\n            if (!associatedPhase) {\n              throw new Error(\n                `${RushConstants.commandLineFilename} defines a parameter \"${normalizedParameter.longName}\" ` +\n                  `that is associated with a phase \"${associatedPhaseName}\" that does not exist.`\n              );\n            } else {\n              associatedPhase.associatedParameters.add(normalizedParameter);\n              parameterHasAssociatedPhases = true;\n            }\n          }\n        }\n\n        if (!parameterHasAssociatedCommands) {\n          throw new Error(\n            `${RushConstants.commandLineFilename} defines a parameter \"${normalizedParameter.longName}\"` +\n              ` that lists no associated commands.`\n          );\n        }\n\n        if (parameterIsOnlyAssociatedWithPhasedCommands && !parameterHasAssociatedPhases) {\n          throw new Error(\n            `${RushConstants.commandLineFilename} defines a parameter \"${normalizedParameter.longName}\" ` +\n              `that is only associated with phased commands, but lists no associated phases.`\n          );\n        }\n      }\n    }\n  }\n\n  private _checkForPhaseSelfCycles(phase: IPhase, checkedPhases: Set<string> = new Set<string>()): void {\n    const phaseSelfDependencies: string[] | undefined = phase.dependencies?.self;\n    if (phaseSelfDependencies) {\n      for (const dependencyName of phaseSelfDependencies) {\n        if (checkedPhases.has(dependencyName)) {\n          const dependencyNameForError: string =\n            typeof dependencyName === 'string' ? dependencyName : '<synthetic phase>';\n          throw new Error(\n            `In ${RushConstants.commandLineFilename}, there exists a cycle within the ` +\n              `set of ${dependencyNameForError} dependencies: ${Array.from(checkedPhases).join(', ')}`\n          );\n        } else {\n          checkedPhases.add(dependencyName);\n          const dependency: IPhase | undefined = this.phases.get(dependencyName);\n          if (!dependency) {\n            return; // Ignore, we check for this separately\n          } else {\n            if (phaseSelfDependencies.length > 1) {\n              this._checkForPhaseSelfCycles(\n                dependency,\n                // Clone the set of checked phases if there are multiple branches we need to check\n                new Set<string>(checkedPhases)\n              );\n            } else {\n              this._checkForPhaseSelfCycles(dependency, checkedPhases);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Loads the configuration from the specified file and applies any omitted default build\n   * settings.  If the file does not exist, then an empty default instance is returned.\n   * If the file contains errors, then an exception is thrown.\n   */\n  public static loadFromFileOrDefault(jsonFilename?: string): CommandLineConfiguration {\n    let commandLineJson: ICommandLineJson | undefined = undefined;\n    if (jsonFilename && FileSystem.exists(jsonFilename)) {\n      commandLineJson = JsonFile.load(jsonFilename);\n\n      // merge commands specified in command-line.json and default (re)build settings\n      // Ensure both build commands are included and preserve any other commands specified\n      if (commandLineJson && commandLineJson.commands) {\n        for (let i: number = 0; i < commandLineJson.commands.length; i++) {\n          const command: CommandJson = commandLineJson.commands[i];\n\n          // Determine if we have a set of default parameters\n          let commandDefaultDefinition: CommandJson | {} = {};\n          switch (command.commandKind) {\n            case RushConstants.bulkCommandKind: {\n              switch (command.name) {\n                case RushConstants.buildCommandName: {\n                  commandDefaultDefinition = DEFAULT_BUILD_COMMAND_JSON;\n                  break;\n                }\n\n                case RushConstants.rebuildCommandName: {\n                  commandDefaultDefinition = DEFAULT_REBUILD_COMMAND_JSON;\n                  break;\n                }\n              }\n              break;\n            }\n          }\n\n          // Merge the default parameters into the repo-specified parameters\n          commandLineJson.commands[i] = {\n            ...commandDefaultDefinition,\n            ...command\n          };\n        }\n\n        CommandLineConfiguration._jsonSchema.validateObject(commandLineJson, jsonFilename);\n      }\n    }\n\n    return new CommandLineConfiguration(commandLineJson);\n  }\n\n  public get additionalPathFolders(): Readonly<string[]> {\n    return this._additionalPathFolders;\n  }\n\n  public prependAdditionalPathFolder(pathFolder: string): void {\n    this._additionalPathFolders.unshift(pathFolder);\n  }\n\n  /**\n   * This function replaces colons (\":\") with underscores (\"_\").\n   *\n   * ts-command-line restricts command names to lowercase letters, numbers, underscores, and colons.\n   * Replacing colons with underscores produces a filesystem-safe name.\n   */\n  private _normalizeNameForLogFilenameIdentifiers(name: string): string {\n    return name.replace(/:/g, '_'); // Replace colons with underscores to be filesystem-safe\n  }\n\n  private _translateBulkCommandToPhasedCommand(command: IBulkCommandJson): IPhasedCommand {\n    const phaseName: string = command.name;\n    const phaseForBulkCommand: IPhase = {\n      name: phaseName,\n      isSynthetic: true,\n      dependencies: {\n        upstream: command.ignoreDependencyOrder ? undefined : [phaseName]\n      },\n      ignoreMissingScript: command.ignoreMissingScript,\n      allowWarningsOnSuccess: command.allowWarningsInSuccessfulBuild,\n      logFilenameIdentifier: this._normalizeNameForLogFilenameIdentifiers(command.name),\n      associatedParameters: new Set()\n    };\n    this.phases.set(phaseName, phaseForBulkCommand);\n    this._syntheticPhasesNamesByTranslatedBulkCommandName.set(command.name, phaseName);\n\n    const translatedCommand: IPhasedCommand = {\n      ...command,\n      commandKind: 'phased',\n      disableBuildCache: true,\n      isSynthetic: true,\n      associatedParameters: new Set<Parameter>(),\n      phases: [phaseName]\n    };\n    return translatedCommand;\n  }\n}\n"]}