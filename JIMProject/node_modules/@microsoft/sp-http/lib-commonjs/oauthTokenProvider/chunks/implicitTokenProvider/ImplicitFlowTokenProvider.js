"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImplicitFlowTokenProvider = void 0;
var sp_diagnostics_1 = require("@microsoft/sp-diagnostics");
var TokenStorage_1 = require("./TokenStorage");
var TokenRequestManager_1 = require("./TokenRequestManager");
var AadKillSwitches_1 = require("../../AadKillSwitches");
/**
 * Class that wraps the replaces ADALs usage.
 * Shamelessly reuses code snippets from ADAL/MSAL.JS
 * Hoping to deprecate/delete when MSAL is production ready.
 * @internal
 */
var ImplicitFlowTokenProvider = /** @class */ (function () {
    function ImplicitFlowTokenProvider(configuration) {
        this._configuration = configuration;
        this._tokenStorage = new TokenStorage_1.TokenStorage(configuration);
        this._tokenRequestManager = new TokenRequestManager_1.TokenRequestManager(configuration);
    }
    /**
     * Performs a retry and drops the login hint.
     * @param resourceUri
     * @param useCachedToken
     */
    ImplicitFlowTokenProvider.prototype.getToken = function (resourceUri, useCachedToken) {
        var _this = this;
        if (useCachedToken === void 0) { useCachedToken = true; }
        var acquireAccessTokenQosMonitor = new sp_diagnostics_1._QosMonitor('ImplicitTokenProvider.GetAccessTokenSilent');
        var extraData = this._tokenRequestManager._generateTelemetryExtraData(resourceUri, this._configuration.spRequestGuid);
        var cachedToken = this._tokenStorage.getToken(resourceUri);
        if (AadKillSwitches_1.AadKillSwitches.isUpdateTokenForImplicitTokenProviderEnabled()
            ? useCachedToken && cachedToken
            : cachedToken) {
            extraData.alias = 'true';
            acquireAccessTokenQosMonitor.writeSuccess(extraData);
            return Promise.resolve(cachedToken);
        }
        return this._tokenRequestManager
            .getToken(resourceUri, true)
            .then(function (response) {
            if (TokenRequestManager_1.TokenRequestManager.isSuccessfulResponse(response)) {
                _this._tokenStorage.saveToken(response, resourceUri);
                acquireAccessTokenQosMonitor.writeSuccess(extraData);
                return response.token;
            }
            else {
                throw new Error(response.errorCode + ': ' + response.errorDescription);
            }
        })
            .catch(function (e) {
            if (TokenRequestManager_1.TokenRequestManager.isExpectedError(e.message)) {
                acquireAccessTokenQosMonitor.writeExpectedFailure('GetTokenFailure', e);
            }
            else {
                acquireAccessTokenQosMonitor.writeUnexpectedFailure('GetTokenFailure', e);
            }
            throw e;
        });
    };
    return ImplicitFlowTokenProvider;
}());
exports.ImplicitFlowTokenProvider = ImplicitFlowTokenProvider;
//# sourceMappingURL=ImplicitFlowTokenProvider.js.map